<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asset Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #8899aa; font-family: monospace; }
        canvas { display: block; }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-bar {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            pointer-events: auto;
            white-space: nowrap;
            overflow-x: auto;
            display: flex;
            gap: 10px;
            height: 60px;
            align-items: center;
        }

        .asset-tile {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            min-width: 80px;
            text-align: center;
            border-radius: 4px;
            transition: background 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 40px;
        }

        .asset-tile:hover {
            background: #555;
        }

        .asset-tile.active {
            background: #FFAA00;
            color: #000;
            border-color: #FFCC00;
        }

        #bottom-bar {
            padding: 10px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-start;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 14px;
        }

        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            font-family: inherit;
        }

        input[type=range] {
            width: 200px;
        }

        #console-container {
            display: none;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
            white-space: pre-wrap;
            border-top: 2px solid #555;
            height: 200px;
            width: 100%;
            box-sizing: border-box;
            pointer-events: auto;
        }

        .log-error { color: #ff5555; }
        .log-warn { color: #ffff55; }
        .log-info { color: #ffffff; }
    </style>
    <!-- Import Map to resolve 'three' -->
    <script type="importmap">
        {
            "imports": {
                "three": "../node_modules/three/build/three.module.js",
                "three/examples/jsm/": "../node_modules/three/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui-layer">
        <div id="top-bar">
            <!-- Tiles injected here -->
        </div>

        <div id="bottom-bar">
            <div class="control-row">
                <label for="light-slider">Light Rotation:</label>
                <input type="range" id="light-slider" min="0" max="360" value="45">
            </div>
            <div class="control-row" style="flex-wrap: wrap;">
                <span>Track Adj:</span>
                <label>Up:</label>
                <select id="track-up-axis" style="width: 80px;">
                    <option value="x" selected>X (Axle)</option>
                    <option value="y">Y (Sky)</option>
                </select>
                <label>X:</label>
                <select id="track-rot-x" style="width: 50px;">
                    <option value="0" selected>0</option>
                    <option value="90">90</option>
                    <option value="180">180</option>
                    <option value="270">270</option>
                </select>
                <label>Y:</label>
                <select id="track-rot-y" style="width: 50px;">
                    <option value="0" selected>0</option>
                    <option value="90">90</option>
                    <option value="180">180</option>
                    <option value="270">270</option>
                </select>
                <label>Z:</label>
                <select id="track-rot-z" style="width: 50px;">
                    <option value="0">0</option>
                    <option value="90">90</option>
                    <option value="180">180</option>
                    <option value="270" selected>270</option>
                </select>
                <label>Spread:</label>
                <input type="range" id="track-spread" min="-2" max="3" step="0.1" value="1.6" style="width: 80px;">
            </div>
            <button id="toggle-console">Show Logs</button>
            <div style="color: white; background: rgba(0,0,0,0.5); padding: 5px;">
                Touch/Drag to Rotate â€¢ Scroll/Pinch to Zoom
            </div>
            <div id="console-container"></div>
        </div>
    </div>

    <script>
        // --- Console Logic ---
        const consoleContainer = document.getElementById('console-container');
        const toggleBtn = document.getElementById('toggle-console');
        let isConsoleOpen = false;

        toggleBtn.addEventListener('click', () => {
            isConsoleOpen = !isConsoleOpen;
            consoleContainer.style.display = isConsoleOpen ? 'block' : 'none';
            toggleBtn.textContent = isConsoleOpen ? 'Hide Logs' : 'Show Logs';
        });

        function appendLog(message, type) {
            const line = document.createElement('div');
            line.className = `log-${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            consoleContainer.appendChild(line);
            consoleContainer.scrollTop = consoleContainer.scrollHeight;
        }

        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;

        console.log = function(...args) {
            originalLog.apply(console, args);
            appendLog(args.join(' '), 'info');
        };

        console.warn = function(...args) {
            originalWarn.apply(console, args);
            appendLog(args.join(' '), 'warn');
        };

        console.error = function(...args) {
            originalError.apply(console, args);
            appendLog(args.join(' '), 'error');
        };

        window.onerror = function(msg, url, lineNo, columnNo, error) {
            const message = `${msg} (${url}:${lineNo}:${columnNo})`;
            console.error(message);
            return false;
        };

        window.addEventListener('error', (event) => {
            if (event.target && (event.target.tagName === 'SCRIPT' || event.target.tagName === 'IMG' || event.target.tagName === 'LINK')) {
                const url = event.target.src || event.target.href || 'unknown source';
                const tag = event.target.tagName;
                const html = event.target.outerHTML ? event.target.outerHTML.substring(0, 100) : 'N/A';
                console.error(`Failed to load resource: <${tag}> ${url}`, `Element: ${html}`);
            }
        }, true);

        window.addEventListener('unhandledrejection', event => {
            console.error('Unhandled Rejection: ' + event.reason);
        });

        console.log("Console initialized.");
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        console.log("Three.js imported successfully.");

        // --- 3D Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x8899aa);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 30, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.zIndex = '-1';

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        // Initial pos will be set by updateLight
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        // Fix for Shadow Acne (Striped artifacts)
        dirLight.shadow.bias = -0.0005;
        dirLight.shadow.normalBias = 0.05;
        scene.add(dirLight);

        // Light Controls
        const lightSlider = document.getElementById('light-slider');
        function updateLight() {
            const angle = lightSlider.value * (Math.PI / 180);
            const radius = 80; // Distance
            const height = 100;

            dirLight.position.x = Math.sin(angle) * radius;
            dirLight.position.z = Math.cos(angle) * radius;
            dirLight.position.y = height;
            dirLight.lookAt(0, 0, 0);
        }
        lightSlider.addEventListener('input', updateLight);
        updateLight(); // Init

        // --- Asset Management ---
        const loader = new GLTFLoader();
        let currentModelGroup = new THREE.Group();
        scene.add(currentModelGroup);

        // Track animated materials and instanced meshes
        const animatedMaterials = [];
        const animatedInstances = []; // { mesh: InstancedMesh, curve: Curve, speed: float }

        const ASSETS = [
            { id: 'bulldozer_components.glb', label: 'Bulldozer (Animated Tracks)' },
            { id: 'bulldozer_composite', label: 'Bulldozer (OpenSCAD)' },
            { id: 'plow.glb', label: 'Plow' },
            { id: 'bulldozer_body.glb', label: 'Body (SCAD)' },
            { id: 'bulldozer_tracks.glb', label: 'Tracks (SCAD)' }
        ];

        // --- UI Setup ---
        const topBar = document.getElementById('top-bar');

        ASSETS.forEach(asset => {
            const tile = document.createElement('div');
            tile.className = 'asset-tile';
            tile.textContent = asset.label;
            tile.onclick = () => loadAsset(asset.id);
            if (window.location.search.includes(asset.id)) {
                tile.classList.add('active');
            }
            topBar.appendChild(tile);
        });

        // --- Procedural Textures ---
        function createProceduralTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            if (type === 'tracks') {
                // Tread pattern
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, 512, 512);
                ctx.fillStyle = '#333';
                // Draw Chevrons
                const barHeight = 64;
                for(let y=0; y<512; y+=barHeight) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(256, y + 32);
                    ctx.lineTo(512, y);
                    ctx.lineTo(512, y + 20);
                    ctx.lineTo(256, y + 52);
                    ctx.lineTo(0, y + 20);
                    ctx.fill();
                }
            } else if (type === 'body') {
                // Metal Scratches/Noise
                ctx.fillStyle = '#FFAA00'; // Base Yellow
                ctx.fillRect(0, 0, 512, 512);

                // Add Noise
                for(let i=0; i<5000; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)';
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const w = Math.random() * 10 + 1;
                    const h = Math.random() * 2 + 1;
                    ctx.fillRect(x, y, w, h);
                }

                // Rust spots
                for(let i=0; i<20; i++) {
                     ctx.fillStyle = 'rgba(100, 50, 0, 0.2)';
                     const x = Math.random() * 512;
                     const y = Math.random() * 512;
                     const r = Math.random() * 50 + 10;
                     ctx.beginPath();
                     ctx.arc(x, y, r, 0, Math.PI*2);
                     ctx.fill();
                }
            } else if (type === 'cabin') {
                // Grey Metal
                ctx.fillStyle = '#888899';
                ctx.fillRect(0, 0, 512, 512);
                // Bolts/Rivets
                 ctx.fillStyle = '#555';
                 for(let x=20; x<512; x+=100) {
                     for(let y=20; y<512; y+=100) {
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, Math.PI*2);
                        ctx.fill();
                     }
                 }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- Triplanar Shader Logic ---
        function enhanceMaterialWithTriplanar(material, isScrolling) {
            material.onBeforeCompile = (shader) => {
                shader.uniforms.uTime = { value: 0 };
                shader.uniforms.uScale = { value: 0.1 }; // Texture scale

                if (isScrolling) {
                    animatedMaterials.push(shader.uniforms);
                }

                // Vertex Shader: Pass world position and normal
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <common>',
                    `
                    #include <common>
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    `
                );
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <worldpos_vertex>',
                    `
                    #include <worldpos_vertex>
                    vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
                    vWorldNormal = normalize(mat3(modelMatrix) * normal);
                    `
                );

                // Fragment Shader: Triplanar Mapping
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <common>',
                    `
                    #include <common>
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    uniform float uTime;
                    uniform float uScale;
                    `
                );

                // Replace the map fragment with triplanar logic
                const triplanarLogic = `
                    vec3 blending = abs(vWorldNormal);
                    blending = normalize(max(blending, 0.00001)); // Avoid div by zero
                    float b = (blending.x + blending.y + blending.z);
                    blending /= b;

                    vec3 coord = vWorldPosition * uScale;

                    // Scrolling logic
                    float scroll = ${isScrolling ? 'uTime * 2.0' : '0.0'};

                    vec4 xaxis = texture2D(map, coord.yz + vec2(0.0, scroll));
                    vec4 yaxis = texture2D(map, coord.xz + vec2(0.0, scroll));
                    vec4 zaxis = texture2D(map, coord.xy + vec2(0.0, scroll));

                    vec4 texColor = xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;

                    diffuseColor *= texColor;
                `;

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <map_fragment>',
                    triplanarLogic
                );
            };
        }


        const loadPart = (filename, textureType, name, isScrolling) => {
            return new Promise((resolve, reject) => {
                const path = `public/assets/${filename}`;
                console.log(`Loading part: ${name} from ${path}`);

                loader.load(path, (gltf) => {
                    const mesh = gltf.scene;
                    const texture = createProceduralTexture(textureType);

                    mesh.traverse((child) => {
                        if (child.isMesh) {
                            const mat = new THREE.MeshStandardMaterial({
                                map: texture,
                                roughness: 0.8,
                                metalness: 0.2
                            });

                            enhanceMaterialWithTriplanar(mat, isScrolling);

                            child.material = mat;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    currentModelGroup.add(mesh);
                    console.log(`Loaded ${name}`);
                    resolve(mesh);
                }, undefined, (error) => {
                    console.error(`Error loading ${name}:`, error);
                    reject(error);
                });
            });
        };

        window.loadAsset = function(assetName) {
            console.log(`Loading asset: ${assetName}`);

            document.querySelectorAll('.asset-tile').forEach(t => t.classList.remove('active'));
            const activeTile = Array.from(document.querySelectorAll('.asset-tile'))
                .find(t => t.textContent.includes(ASSETS.find(a => a.id === assetName)?.label));
            if (activeTile) activeTile.classList.add('active');

            while(currentModelGroup.children.length > 0){
                currentModelGroup.remove(currentModelGroup.children[0]);
            }
            // Clear animations
            animatedMaterials.length = 0;
            animatedInstances.length = 0;
            currentModelGroup.position.set(0,0,0);
            currentModelGroup.rotation.set(0,0,0);

            if (assetName === 'bulldozer_composite') {
                Promise.all([
                    loadPart('bulldozer_body.glb', 'body', 'Body', false),
                    loadPart('bulldozer_tracks.glb', 'tracks', 'Tracks', true),
                    loadPart('bulldozer_cabin.glb', 'cabin', 'Cabin', false)
                ]).then(() => {
                    const box = new THREE.Box3().setFromObject(currentModelGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    currentModelGroup.position.sub(center);
                    controls.target.set(0, 0, 0);
                }).catch(e => console.error("Composite Load Failed", e));
            }
            else if (assetName === 'bulldozer_components.glb') {
                const path = `public/assets/${assetName}`;
                console.log(`Loading complex Blender asset: ${path}`);

                loader.load(path, (gltf) => {
                    // Extract components
                    let bodyMesh = null;
                    let linkGeo = null;
                    let linkMat = null;
                    let leftPathPoints = null;
                    let rightPathPoints = null;

                    // Parse GLTF children manually to find our specific named objects
                    // Note: GLTF structure might have scenes/nodes.
                    gltf.scene.traverse((child) => {
                        console.log(`Found node: ${child.name} (${child.type})`);

                        if (child.name.includes("Bulldozer_Body") && child.isMesh) {
                            bodyMesh = child.clone();
                        }
                        else if (child.name.includes("Asset_TrackLink") && child.isMesh) {
                            linkGeo = child.geometry;
                            linkMat = child.material;
                        }
                        else if (child.name.includes("Asset_TrackPath_L")) {
                            // Extract vertices from the line loop
                            if (child.isMesh || child.isLine) {
                                const attr = child.geometry.attributes.position;
                                leftPathPoints = [];
                                for (let i = 0; i < attr.count; i++) {
                                    leftPathPoints.push(new THREE.Vector3().fromBufferAttribute(attr, i));
                                }
                            }
                        }
                        else if (child.name.includes("Asset_TrackPath_R")) {
                             if (child.isMesh || child.isLine) {
                                const attr = child.geometry.attributes.position;
                                rightPathPoints = [];
                                for (let i = 0; i < attr.count; i++) {
                                    rightPathPoints.push(new THREE.Vector3().fromBufferAttribute(attr, i));
                                }
                            }
                        }
                    });

                    // 1. Add Body
                    if (bodyMesh) {
                        bodyMesh.castShadow = true;
                        bodyMesh.receiveShadow = true;
                        currentModelGroup.add(bodyMesh);
                    } else {
                        console.error("Could not find Bulldozer_Body");
                    }

                    // 2. Create Instanced Tracks
                    const setupTrack = (points, speed, side) => {
                        if (!points || !linkGeo) return;

                        // Close the loop for CatmullRom
                        // Use centripetal to avoid loops/overshoot on straight sections
                        const curve = new THREE.CatmullRomCurve3(points, true, 'centripetal', 0.5);

                        const count = 50;
                        const mesh = new THREE.InstancedMesh(linkGeo, linkMat, count);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // Update every frame

                        currentModelGroup.add(mesh);

                        animatedInstances.push({
                            mesh: mesh,
                            curve: curve,
                            count: count,
                            speed: speed, // 0-1 per second
                            offset: 0,
                            side: side
                        });
                    };

                    setupTrack(leftPathPoints, 0.2, -1);
                    setupTrack(rightPathPoints, 0.2, 1); // Same speed for now

                    // Center view
                    const box = new THREE.Box3().setFromObject(currentModelGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    currentModelGroup.position.sub(center);
                    controls.target.set(0, 0, 0);

                }, undefined, (error) => console.error(error));
            }
            else {
                 const path = `public/assets/${assetName}`;
                 loader.load(path, (gltf) => {
                    const mesh = gltf.scene;
                    currentModelGroup.add(mesh);

                    let texType = 'body';
                    let scrolling = false;
                    if (assetName.includes('tracks')) { texType = 'tracks'; scrolling = true; }
                    if (assetName.includes('cabin')) texType = 'cabin';

                    const texture = createProceduralTexture(texType);

                     mesh.traverse((child) => {
                        if (child.isMesh) {
                            const mat = new THREE.MeshStandardMaterial({
                                map: texture,
                                roughness: 0.8,
                                metalness: 0.2
                            });
                            enhanceMaterialWithTriplanar(mat, scrolling);
                            child.material = mat;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    const box = new THREE.Box3().setFromObject(mesh);
                    const center = box.getCenter(new THREE.Vector3());
                    mesh.position.sub(center);
                    controls.target.set(0, 0, 0);

                 }, undefined, (error) => console.error(error));
            }
        };

        // Initialize
        const params = new URLSearchParams(window.location.search);
        const initAsset = params.get('asset') || 'bulldozer_components.glb';
        loadAsset(initAsset);

        window.setAngle = (angleDegrees) => {
             currentModelGroup.rotation.y = angleDegrees * Math.PI / 180;
        };

        const clock = new THREE.Clock();
        const dummy = new THREE.Object3D();

        // Reusable vectors to prevent Garbage Collection stutter
        const _position = new THREE.Vector3();
        const _tangent = new THREE.Vector3();
        const _lookAtTarget = new THREE.Vector3();
        const _trackUpX = new THREE.Vector3(1, 0, 0);
        const _trackUpY = new THREE.Vector3(0, 1, 0);

        // Track UI State
        const trackParams = {
            up: _trackUpX,
            rotX: 0,
            rotY: 0,
            rotZ: 0,
            spread: 0
        };

        function updateTrackParams() {
            const upAxis = document.getElementById('track-up-axis').value;
            trackParams.up = (upAxis === 'x') ? _trackUpX : _trackUpY;
            trackParams.rotX = parseFloat(document.getElementById('track-rot-x').value) * Math.PI / 180;
            trackParams.rotY = parseFloat(document.getElementById('track-rot-y').value) * Math.PI / 180;
            trackParams.rotZ = parseFloat(document.getElementById('track-rot-z').value) * Math.PI / 180;
            trackParams.spread = parseFloat(document.getElementById('track-spread').value);
        }

        // Listeners for track params
        ['track-up-axis', 'track-rot-x', 'track-rot-y', 'track-rot-z', 'track-spread'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateTrackParams);
            if(id === 'track-spread') document.getElementById(id).addEventListener('input', updateTrackParams);
        });
        updateTrackParams();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. Update shader-based animations (scrolling texture)
            animatedMaterials.forEach(uniforms => {
                uniforms.uTime.value += delta;
            });

            // 2. Update geometric animations (instanced tracks)
            animatedInstances.forEach(track => {
                // Move the track offset
                track.offset = (track.offset + track.speed * delta) % 1.0;

                for (let i = 0; i < track.count; i++) {
                    // Calculate position t (0..1)
                    const t = (i / track.count + track.offset) % 1.0;

                    // Get point/tangent without creating new objects (using copy)
                    track.curve.getPointAt(t, _position);
                    track.curve.getTangentAt(t, _tangent);

                    // GIMBAL LOCK FIX:
                    // Since tracks move along Y/Z, we force the "Up" reference to be X.
                    // This prevents the flip when the track is flat on the ground.
                    dummy.up.copy(trackParams.up);

                    dummy.position.copy(_position);

                    // Calculate target without .clone()
                    _lookAtTarget.copy(_position).add(_tangent);
                    dummy.lookAt(_lookAtTarget);

                    // Apply UI corrections
                    if (trackParams.rotX) dummy.rotateX(trackParams.rotX);
                    if (trackParams.rotY) dummy.rotateY(trackParams.rotY);
                    if (trackParams.rotZ) dummy.rotateZ(trackParams.rotZ);

                    if (trackParams.spread) {
                        // Spread moves tracks away from center along Up axis
                        dummy.position.addScaledVector(trackParams.up, trackParams.spread * track.side);
                    }

                    dummy.updateMatrix();
                    track.mesh.setMatrixAt(i, dummy.matrix);
                }

                // Notify GPU
                track.mesh.instanceMatrix.needsUpdate = true;
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
