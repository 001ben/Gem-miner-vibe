{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation Index","text":"<p>Welcome to the Gem Miner technical documentation.</p>"},{"location":"#guides-reference","title":"\ud83d\udcda Guides &amp; Reference","text":"<ul> <li> Project Structure: Overview of the codebase layout, including source, pipeline, and tools.</li> <li> Taskfile Commands: How to build, run, and verify the project.</li> </ul>"},{"location":"#architecture-damp","title":"\ud83c\udfd7 Architecture (DAMP)","text":"<p>The Distributed Asset &amp; Material Pipeline (DAMP) is the core of our asset generation workflow.</p> <ul> <li> Maintainability \"Bible\": The \"Explicit Contract\" model and core pillars.</li> <li> Pipeline Review: Context on the transition to DAMP.</li> <li> Blender Pipeline: How to create assets using our Python API.</li> </ul>"},{"location":"#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":"<ul> <li> Common Errors: Setup and runtime issues.</li> <li> Graphics Troubleshooting: Visual artifacts and rendering fixes.</li> </ul>"},{"location":"#planning","title":"\ud83d\uddd3 Planning","text":"<ul> <li>:material-roadmap: Roadmap: High-level goals and backlog.</li> <li> Current Task: Status of the current active work.</li> <li> History: Past session logs and decision records.</li> </ul>"},{"location":"architecture/BLENDER_PIPELINE/","title":"Asset Generation: The \"Game Ready\" Pipeline (Blender + Python)","text":"<p>While OpenSCAD is excellent for \"Programmer CAD,\" it struggles with game-specific needs like UV Mapping and Topology. We have introduced a second pipeline option: Blender Python Scripting.</p> <p>This allows you to generate assets using Python code (keeping the \"Programmer\" workflow) while leveraging Blender's industry-standard tools for UV unwrapping and GLTF export.</p>"},{"location":"architecture/BLENDER_PIPELINE/#architecture","title":"Architecture","text":"<ol> <li>Source: Python scripts (<code>.py</code>) located in <code>pipeline/blender/</code>.</li> <li>Engine: Blender (headless mode).</li> <li>Compilation: <code>task build:assets</code> runs Blender to execute the script and export <code>.glb</code>.</li> <li>Result: Game-ready assets with UVs, Materials, and Explicit IDs.</li> </ol>"},{"location":"architecture/BLENDER_PIPELINE/#how-to-use","title":"How to use","text":"<ol> <li>Create a python script in <code>pipeline/blender/my_asset.py</code>.</li> <li>Use the <code>bpy</code> library to generate geometry.</li> <li>Run <code>task build:assets</code>.</li> </ol> <p>Tip: Headless Mode</p> <p>The pipeline runs Blender in background mode (<code>-b</code>), so no UI window will open. If you need to debug geometry, you can open the generated GLB in a standard GLTF viewer or open Blender manually to run the script.</p>"},{"location":"architecture/BLENDER_PIPELINE/#example-blender-script","title":"Example Blender Script","text":"<pre><code>import bpy\n\n# Clear existing\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create Cube\nbpy.ops.mesh.primitive_cube_add(size=2)\nobj = bpy.context.object\n\n# Tag for DAMP\nobj[\"damp_id\"] = \"test_cube\"\n\n# Auto UV Unwrap\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.uv.smart_project()\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Export logic is handled by the wrapper script,\n# but locally you might verify with:\n# bpy.ops.export_scene.gltf(filepath=\"my_asset.glb\")\n</code></pre>"},{"location":"architecture/DAMP_MAINTAINABILITY/","title":"DAMP Architecture &amp; Rationale","text":"<p>Distributed Asset &amp; Material Pipeline (DAMP)</p> <p>This document outlines the architectural decisions and \"Explicit Contract\" model that governs the asset pipeline for the Gem Miner project.</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#1-core-philosophy-explicit-implicit","title":"1. Core Philosophy: \"Explicit &gt; Implicit\"","text":"<p>The primary design principle is Explicit Contracts. We avoid \"Implicit Logic\" (guessing mesh names like <code>Cube001</code>, assuming default alignments, or relying on runtime discovery).</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#the-contract-model","title":"The Contract Model","text":"<ul> <li>Blender (Provider): Explicitly tags Materials and Objects with a permanent <code>damp_id</code> custom property.</li> <li>GLB (Artifact): Carries these IDs in the standard <code>extras</code> or <code>userData</code> fields.</li> <li>Renderer (Consumer): Strictly enforces the contract. It looks for <code>damp_id</code> and maps functionality to it.</li> </ul> <p>Implicit Logic (Bad)</p> <p>Searching for mesh names like <code>Cube001</code> or <code>Cylinder</code> is fragile because Blender often renames things automatically.</p> <p>Explicit Contract (Good)</p> <p>The renderer only cares about <code>damp_id=\"chassis\"</code>. The geometry name can be anything.</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#2-the-four-pillars-structure","title":"2. The \"Four Pillars\" Structure","text":"<p>To maintain separation of concerns, the codebase is divided into four distinct domains:</p> <ol> <li><code>src/</code> (Game Source): The runtime game logic. It consumes assets but does not generate them.</li> <li><code>pipeline/</code> (Asset Factory): The \"Source of Truth\" for assets. Contains Blender Python scripts and procedural texture generators.</li> <li><code>tools/</code> (DX Tools): Developer tools like the Asset Viewer (<code>tools/viewer</code>) that verify assets in isolation.</li> <li><code>assets/</code> (Output/Artifacts): The compiled <code>.glb</code> and configuration files.</li> </ol>"},{"location":"architecture/DAMP_MAINTAINABILITY/#3-pipeline-flow","title":"3. Pipeline Flow","text":"<p>The asset generation flow is automated via <code>task build:assets</code>:</p> <pre><code>graph LR\n    A[Blender Script] --&gt;|Generate &amp; Tag| B(GLB Artifact)\n    B --&gt;|Load| C[Asset Viewer]\n    B --&gt;|Load| D[Game Engine]\n</code></pre> <ol> <li>Generation: <code>pipeline/blender/bulldozer.py</code> generates geometry, parents objects, injects <code>damp_id</code>, and bakes transforms.</li> <li>Compilation: Exports a <code>.glb</code> and updates <code>catalog.json</code>.</li> <li>Consumption: <code>BulldozerRenderer</code> loads the GLB and applies materials based on IDs.</li> </ol>"},{"location":"architecture/DAMP_MAINTAINABILITY/#4-key-architectural-decisions-rationale","title":"4. Key Architectural Decisions (Rationale)","text":""},{"location":"architecture/DAMP_MAINTAINABILITY/#a-parenting-vs-joining","title":"A. Parenting vs. Joining","text":"<p>Decision</p> <p>Use Object Parenting, not <code>bpy.ops.object.join()</code>.</p> <p>Rationale: Joining meshes destroys object-level metadata and forces Three.js to split primitives at runtime, causing race conditions and losing the <code>damp_id</code> on sub-parts. Parenting preserves the logical hierarchy and metadata.</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#b-material-level-tagging","title":"B. Material-Level Tagging","text":"<p>Decision</p> <p>Tag Materials (<code>mat[\"damp_id\"]</code>) in addition to Objects.</p> <p>Rationale: Custom properties on Materials are more resilient. Even if geometry is merged or instanced, Three.js preserves material slots, allowing the renderer to reliably identify \"Glass\" vs \"Steel\" parts.</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#c-baked-transforms","title":"C. Baked Transforms","text":"<p>Decision</p> <p>Bake scale and rotation in Blender; avoid runtime adjustments.</p> <p>Rationale: Early iterations attempted to fix rotation (Y-up vs Z-up) in JavaScript. This led to \"Tiny Bodies and Giant Tracks\" bugs. Baking the transforms ensures that <code>(1,1,1)</code> in the game engine matches the intended visual size.</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#d-centralized-utilities","title":"D. Centralized Utilities","text":"<p>Decision</p> <p>Move cache-busting (<code>cb()</code>) and common logic to <code>src/utils/graphics-utils.js</code>.</p> <p>Rationale: Previously, the Viewer and the Game had separate utility implementations, leading to \"ghost bugs\" where one saw cached assets and the other saw new ones. A shared utility ensures consistency.</p>"},{"location":"architecture/DAMP_MAINTAINABILITY/#5-component-lifecycle","title":"5. Component Lifecycle","text":"<p>The standard lifecycle for an asset-based entity (like the Bulldozer) is:</p> <ol> <li><code>init()</code>: Physics body created (invisible).</li> <li><code>load()</code>: <code>BulldozerRenderer</code> fetches the GLB.</li> <li><code>setup()</code>:<ul> <li>Traverses GLB.</li> <li>Identifies Tracks (extracts Curves).</li> <li>Identifies Chassis/Parts (applies Materials).</li> </ul> </li> <li><code>update()</code>: Syncs the root Mesh position/rotation to the Physics Body.</li> </ol> <p>Last Updated: 2025-05-19</p>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/","title":"DAMP Pipeline Review &amp; Design Commentary","text":""},{"location":"architecture/DAMP_PIPELINE_REVIEW/#1-architectural-overview","title":"1. Architectural Overview","text":"<p>The Distributed Asset &amp; Material Pipeline (DAMP) successfully bridges the gap between Programmatic CAD (Blender/Python) and Real-time Web Rendering (Three.js). It follows a \"Source-of-Truth\" model where geometry is generated on-demand, and a JSON configuration layer decouples the visual styling from the raw mesh data.</p>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#the-flow","title":"The Flow:","text":"<ol> <li>Geometry (<code>bulldozer.py</code>): Defines the \"bones\" and \"shell\" of the entity using Blender's Python API.</li> <li>Texture Gen (<code>bulldozer.py</code>): Captures procedural details into static PNGs to avoid expensive real-time procedural overhead.</li> <li>Orchestration (<code>build-assets.js</code>): Compiles raw assets into a <code>catalog.json</code> for the web runtime and ensures consistent directory structures.</li> <li>Configuration (<code>bulldozer_mapping.json</code>): Defines the \"skin\"\u2014mapping textures and material physics (roughness, metalness, transparency) to specific meshes.</li> <li>Runtime (<code>bulldozer_render.js</code>): Interprets the GLB + Config to assemble the final high-fidelity entity in the game engine.</li> </ol>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#2-design-commentary","title":"2. Design Commentary","text":""},{"location":"architecture/DAMP_PIPELINE_REVIEW/#strengths","title":"Strengths","text":"<ul> <li>WYSIWYG Development: The Asset Director (Viewer) allows for real-time material tuning that can be exported directly to the game's config files.</li> <li>Decoupled Logic: Geometry changes in Blender don't require code changes in the game engine, provided the naming conventions remain stable.</li> <li>Performance Optimization: By baking procedural textures into PNGs during the build step, client-side GPU load is kept low while maintaining high visual detail.</li> <li>Material Presets: The \"Preset\" system (e.g., Glass, Track) allows for high-fidelity Three.js materials to be defined in code while still being configurable via JSON.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#current-challenges-the-magic-mapping","title":"Current Challenges (The \"Magic\" Mapping)","text":"<p>The most brittle part of the current design is the Generic Mesh Mapping.</p> <ul> <li>Issue: When Blender joins meshes, it creates names like <code>Cube001</code>, <code>Cube001_1</code>. The renderer has to \"guess\" that <code>Cube001_1</code> is a wheel based on material or generic string matches.</li> <li>Risk: Changes in Blender's joining order could swap these names, breaking the texture mapping in the game.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#3-technical-review-cleanup","title":"3. Technical Review &amp; Cleanup","text":""},{"location":"architecture/DAMP_PIPELINE_REVIEW/#assetssourceblenderbulldozerpy","title":"<code>assets/source/blender/bulldozer.py</code>","text":"<ul> <li>Review: Highly functional script. Current logic joins components (Cabin/Body) into a single mesh for simplicity.</li> <li>Suggestion: Transition to Parenting instead of <code>bpy.ops.object.join()</code>. Keeping components as separate objects in the GLB allows the renderer to find them directly by name without complex mapping logic.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#jsentitiesbulldozer_renderjs","title":"<code>js/entities/bulldozer_render.js</code>","text":"<ul> <li>Review: The <code>applyMaterial</code> logic currently performs heavy string matching to \"fix\" generic Blender export names.</li> <li>Cleanup: Standardize the <code>cb()</code> (cache-busting) utility across the project to reduce code duplication.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#viewersrcmainjs","title":"<code>viewer/src/main.js</code>","text":"<ul> <li>Review: The UI \"Discovery\" logic is clever but can be prone to race conditions with the renderer's initial load.</li> <li>Cleanup: Centralize component discovery within the <code>BulldozerRenderer</code> itself.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#4-proposed-improvements-roadmap","title":"4. Proposed Improvements (Roadmap)","text":""},{"location":"architecture/DAMP_PIPELINE_REVIEW/#phase-1-explicit-component-tagging-high-priority","title":"Phase 1: Explicit Component Tagging (High Priority)","text":"<p>Instead of matching strings like <code>\"Cube\"</code>, we should use Blender Custom Properties.</p> <ul> <li>Blender Python: <code>obj[\"damp_id\"] = \"Chassis\"</code></li> <li>Three.js Runtime: The GLTF loader preserves these in <code>mesh.userData.damp_id</code>.</li> <li>Result: 100% reliable mapping regardless of mesh joining or renaming.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#phase-2-unified-material-schema","title":"Phase 2: Unified Material Schema","text":"<p>Formalize the mapping JSON into a generic schema that supports:</p> <ul> <li><code>emissive</code> properties for glowing lights.</li> <li><code>normalMap</code> support for surface bump details.</li> <li><code>envMapIntensity</code> for more realistic glass reflections.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#phase-3-build-pipeline-hardening","title":"Phase 3: Build Pipeline Hardening","text":"<ul> <li>Schema Validation: Validate JSON configs against a schema during the build step to catch typos before runtime.</li> <li>Automated Thumbnails: Integrate a headless browser step to generate preview thumbnails for the <code>catalog.json</code>.</li> </ul>"},{"location":"architecture/DAMP_PIPELINE_REVIEW/#5-immediate-cleanup-checklist","title":"5. Immediate Cleanup Checklist","text":"<ul> <li> Consolidate Utilities: Move <code>cb()</code> cache-busting to a shared utility file.</li> <li> Blender Refactor: Update <code>bulldozer.py</code> to use parenting instead of joining for critical components.</li> <li> Remove Legacy Artifacts: Delete <code>existing_pipeline_files.txt</code> and unused <code>/verification</code> scripts.</li> <li> Standardize Interfaces: Ensure all renderers use the same <code>setPose(position, angle)</code> interface.</li> </ul> <p>Review Date: Thursday 18 December 2025</p>"},{"location":"archive/ASSET_PIPELINE/","title":"Asset Pipeline &amp; Material Challenges","text":""},{"location":"archive/ASSET_PIPELINE/#current-architecture","title":"Current Architecture","text":"<p>Our \"Programmer CAD\" pipeline currently operates as follows:</p> <ol> <li>Source: Parametric geometry defined in OpenSCAD (<code>.scad</code>).</li> <li>Compilation: OpenSCAD CLI exports the geometry to ASCII STL.</li> <li>Conversion: A custom script (<code>stl2obj.js</code>) converts STL to OBJ.</li> <li>Packaging: <code>obj2gltf</code> converts OBJ to binary GLTF (<code>.glb</code>).</li> </ol>"},{"location":"archive/ASSET_PIPELINE/#implemented-strategy-component-based-assembly","title":"Implemented Strategy: Component-Based Assembly","text":"<p>To solve the \"monolithic mesh\" color limitation of STL, we have adopted a Component-Based Assembly strategy.</p> <ul> <li>Workflow:<ul> <li>Instead of one <code>bulldozer.scad</code>, we maintain separate source files:<ul> <li><code>bulldozer_body.scad</code></li> <li><code>bulldozer_tracks.scad</code></li> <li><code>bulldozer_cabin.scad</code></li> </ul> </li> <li>The build pipeline (<code>npm run build:assets</code>) compiles these individually into <code>.glb</code> files.</li> </ul> </li> <li>Runtime Assembly:<ul> <li>The game engine (Three.js) loads these separate assets.</li> <li>They are added to a single <code>THREE.Group</code> container.</li> <li>Colors/Materials: Because each part is a distinct mesh, we can assign different materials to them programmatically (e.g., <code>bodyMesh.material = yellowMaterial</code>, <code>tracksMesh.material = darkMaterial</code>).</li> </ul> </li> </ul>"},{"location":"archive/ASSET_PIPELINE/#future-roadmap-advanced-visuals-best-practices","title":"Future Roadmap: Advanced Visuals &amp; Best Practices","text":"<p>As we look to move beyond simple solid colors, here are the challenges and best practices for a \"Programmer CAD\" (Code-first) workflow vs. a traditional Artist workflow.</p>"},{"location":"archive/ASSET_PIPELINE/#1-textures-surface-detail","title":"1. Textures &amp; Surface Detail","text":"<p>The Challenge: Standard 3D texturing relies on UV Mapping\u2014unwrapping a 3D object onto a 2D plane so an image can be painted on it. OpenSCAD / CSG (Constructive Solid Geometry) tools do not generate UV maps automatically, and \"unwrapping\" a procedurally generated mesh manually defeats the purpose of an automated pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Triplanar Mapping: Instead of using UVs, use a special shader (or Three.js node material) that projects textures onto the object from the Top, Front, and Side (X, Y, Z axes). This allows you to apply \"Dirt\", \"Rust\", or \"Scratches\" textures to any shape without manual work.</li> <li>Matcaps (Material Capture): Use <code>THREE.MeshMatcapMaterial</code>. This uses a spherical reference image to fake complex lighting and reflection (e.g., chrome, shiny car paint) cheaply. It looks great and requires no UVs.</li> <li>Decals: For specific details (like a \"Hazard Stripe\" or a Logo), use a separate floating mesh or a \"Decal\" geometry placed slightly above the surface, rather than trying to texture the main body.</li> </ul>"},{"location":"archive/ASSET_PIPELINE/#2-animations","title":"2. Animations","text":"<p>The Challenge: Traditional game assets use \"Skinned Meshes\" (bones/skeletons) to deform geometry (e.g., a character bending their arm). OpenSCAD exports static rigid meshes. We cannot easily add \"bones\" to an STL file in this pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Hierarchical / Rigid Body Animation: This is what we already support with the Component-Based Assembly.<ul> <li>Example: To animate the plow moving up and down, we do not bend the metal. We verify the <code>plow.glb</code> is its own object, and in the game code, we change its <code>position.y</code> or <code>rotation.x</code>.</li> <li>Example: To animate tracks, we don't deform the rubber. We scroll the texture on the tracks (UV offset animation) or rotate the wheels if they are separate parts.</li> </ul> </li> <li>Code-Driven Motion: All animation should be driven by game state (physics, input), not pre-baked animation clips (like an <code>.fbx</code> file might have). This gives the \"programmer\" ultimate control.</li> </ul>"},{"location":"archive/ASSET_PIPELINE/#summary-of-programmer-art-stack","title":"Summary of \"Programmer Art\" Stack","text":"Feature Traditional Workflow (Blender/Maya) Our Workflow (OpenSCAD/Three.js) Geometry Hand-modeled polygons Code-defined primitives (CSG) Colors Texture Maps / Vertex Paint Separate Parts / Runtime Materials Textures Manual UV Unwrapping Triplanar Mapping / Matcaps Animation Skeletal Rigging / Keyframes Hierarchical Code Manipulation <p>Next Steps Recommendation:</p> <ol> <li>Stick to solid colors for now to keep the style clean (e.g., \"Low Poly\" aesthetic).</li> <li>If detail is needed, explore Triplanar Mapping shaders to add noise/grit without needing asset changes.</li> <li>For the plow animation, ensure the plow is a separate asset from the body so it can be moved independently in code.</li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/","title":"Tutorial: The Bulldozer Renderer","text":""},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#1-the-high-level-goal","title":"1. The High-Level Goal","text":"<p>This file is responsible for:</p> <ol> <li>Loading the 3D model of the bulldozer.</li> <li>Painting it (creating textures via code, so no image files are needed).</li> <li>Animating the tank tracks so they look like they are rolling.</li> <li>Syncing the visual position with the physics body (Matter.js).</li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#2-generating-textures-procedurally","title":"2. Generating Textures \"Procedurally\"","text":"<p>Instead of loading JPG or PNG images (which takes time and bandwidth), this code \"draws\" its own textures using a virtual HTML Canvas.</p> <p>Function: <code>createProceduralTexture(type)</code></p> <ul> <li>How it works: It creates a hidden <code>&lt;canvas&gt;</code> element in memory, gets a 2D drawing context (<code>ctx</code>), and draws shapes.</li> <li>The \"Tracks\" Texture: It draws a dark background and then loops to draw chevron/V-shapes. This creates the tread pattern.</li> <li>The \"Body\" Texture: It draws a yellow square, then scatters random noise (dots) and rust spots to make it look like weathered metal.</li> <li>Three.js Conversion: Finally, <code>new THREE.CanvasTexture(canvas)</code> turns that drawing into something the 3D engine can wrap around a shape.</li> </ul> <pre><code>// Example logic simplified:\nif (type === 'tracks') {\n    ctx.fillStyle = '#333';\n    // Draw zig-zag lines for treads...\n}\nreturn new THREE.CanvasTexture(canvas);\n</code></pre>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#3-the-shader-magic-advanced","title":"3. The Shader Magic (Advanced)","text":"<p>Standard 3D models need \"UV Maps\" (instructions on how to wrap a 2D image around a 3D object). This file uses a clever trick called Triplanar Mapping to avoid needing perfect UVs.</p> <p>Function: <code>enhanceMaterialWithTriplanar(...)</code></p> <ul> <li>What is a Shader? A shader is a small program that runs on your Graphics Card (GPU) to decide the color of every single pixel.</li> <li>The Trick: It intercepts the standard Three.js material code (<code>onBeforeCompile</code>) and injects custom logic.</li> <li>Triplanar Logic: Instead of stretching a texture, it projects the texture from three directions (Top, Side, Front) and blends them together.</li> <li>Scrolling: For the tracks, it adds a <code>uTime</code> variable to slide the texture coordinates, making the treads look like they are moving without actually moving the geometry.</li> </ul>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#4-the-main-class-bulldozerrenderer","title":"4. The Main Class: <code>BulldozerRenderer</code>","text":""},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-constructor","title":"The Constructor","text":"<p>When <code>new BulldozerRenderer(scene)</code> is called:</p> <ol> <li>It creates a <code>THREE.Group</code>. Think of this as an invisible box that will hold all the bulldozer parts (body, glass, tracks).</li> <li>It creates a <code>GLTFLoader</code>. This is the tool that knows how to read <code>.glb</code> (3D model) files.</li> <li>It prepares empty lists (<code>animatedInstances</code>) to track things that need to move every frame.</li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-loadurl-method","title":"The <code>load(url)</code> method","text":"<p>This is the heavy lifter. It fetches the file and organizes the parts.</p> <ol> <li>Finding Parts: It loops through every object in the 3D file:<ul> <li>If the name contains \"Bulldozer_Body\", it keeps it as the chassis.</li> <li>If the name contains \"Asset_TrackLink\", it keeps track of track link to load.</li> <li>If the name contains \"Asset_TrackPath\", it reads the mathematical points to know the shape of the tracks (oval-ish).</li> </ul> </li> <li>Applying Materials: It creates the shiny glass material and the rough metal material (using the procedural textures from step 2).</li> <li>Building Tracks (InstancedMesh):<ul> <li>Instead of creating 50 separate 3D objects for the track links (which is slow), it uses <code>InstancedMesh</code>.</li> <li>This tells the GPU: \"Draw this one shape 50 times at these 50 different positions.\" It's a huge performance optimization.</li> <li>It uses <code>THREE.CatmullRomCurve3</code> to calculate a smooth path along the points found in the file.</li> </ul> </li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-setposeposition-angle-method","title":"The <code>setPose(position, angle)</code> method","text":"<p>This is the bridge between the Physics world (Matter.js) and the Visual world (Three.js).</p> <ul> <li>Matter.js (2D) calculates where the box is.</li> <li>Three.js (3D) needs to know where to draw it.</li> <li>This function copies the X/Y from physics to X/Z in 3D (since Y is \"up\" in 3D) and applies the rotation.</li> </ul> <pre><code>setPose(position, angle) {\n    this.group.position.set(position.x, 0, position.y); // Map 2D -&gt; 3D\n    this.group.rotation.y = -angle; // Rotate the model\n}\n</code></pre>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-updatedelta-method","title":"The <code>update(delta)</code> method","text":"<p>This runs 60 times a second (the game loop).</p> <ol> <li>Shader Time: It increases the <code>uTime</code> value so the track textures keep scrolling.</li> <li>Track Movement: It calculates the position of every single track link along the curve.<ul> <li><code>track.curve.getPointAt(t)</code>: \"Where is the link at 50% along the curve?\"</li> <li><code>track.curve.getTangentAt(t)</code>: \"Which way should it face?\"</li> <li>It updates the matrix (position+rotation) for all 50 track links instantly.</li> </ul> </li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#summary","title":"Summary","text":"<ul> <li><code>bulldozer.js</code> is the \"Brain\" (Physics, Collision).</li> <li><code>bulldozer_render.js</code> is the \"Costume\" (Graphics).</li> <li>It generates its own \"fabric\" (textures) via code.</li> <li>It uses a \"Green Screen\" trick (Shaders) to animate the texture scrolling.</li> <li>It listens to the \"Brain\" every frame via <code>setPose</code> to know where to stand.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/","title":"Graphics System Design &amp; Analysis","text":""},{"location":"archive/GRAPHICS_DESIGN/#current-implementation","title":"Current Implementation","text":"<p>The current graphics implementation relies on a \"Programmer Art\" approach where 3D visuals are generated procedurally at runtime using Three.js primitives (<code>BoxGeometry</code>, <code>TorusGeometry</code>, <code>IcosahedronGeometry</code>).</p>"},{"location":"archive/GRAPHICS_DESIGN/#architecture","title":"Architecture","text":"<ul> <li>State Synchronization: The <code>updateGraphics()</code> loop iterates through all Matter.js physics bodies every frame.</li> <li>1:1 Mapping: Each physics body part (including compound body parts) creates and manages its own independent Three.js mesh.</li> <li>Procedural Generation: Visuals like the Bulldozer, Plow, and Collector are constructed by combining simple geometric shapes in code. Texture atlases or external models are not used.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#deviation-from-standard-practices","title":"Deviation from Standard Practices","text":"<p>Industry-standard web game development (using engines like Three.js, Babylon, or PlayCanvas) typically follows different patterns:</p> <ol> <li> <p>Asset-Based Workflow:</p> <ul> <li>Standard: Artists create models in tools like Blender/Maya/3ds Max and export them as <code>GLTF</code>/<code>GLB</code> files. These assets contain optimized geometry, UV maps, materials, and animations.</li> <li>Current: Geometry is hard-coded. Adjusting the \"look\" (e.g., curving a plow) requires complex trigonometric math and geometry manipulation in code rather than moving vertices in an editor.</li> </ul> </li> <li> <p>Scene Graph Hierarchy:</p> <ul> <li>Standard: A single visual root object represents a game entity (e.g., a Tank). Physics bodies update the root's transform, and child nodes (turret, wheels) are animated relative to that root.</li> <li>Current: Every physics sub-part (chassis, wheel, plow) drives its own mesh directly. This ensures tight physics matching but makes complex visual articulation (like suspension or smooth interpolation) harder to implement.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Standard: Use InstancedMesh for identical objects (like Gems). This allows rendering thousands of items with a single draw call.</li> <li>Current: Each Gem is a separate <code>Mesh</code> object. While Three.js handles frustum culling, the CPU overhead of updating thousands of individual scene graph nodes every frame limits the maximum gem density.</li> </ul> </li> </ol>"},{"location":"archive/GRAPHICS_DESIGN/#opportunities-for-improvement","title":"Opportunities for Improvement","text":""},{"location":"archive/GRAPHICS_DESIGN/#1-asset-pipeline-integration","title":"1. Asset Pipeline Integration","text":"<p>Moving to a GLTF loader workflow would immediately improve visual fidelity.</p> <ul> <li>Action: Create a <code>AssetManager</code> class to load <code>.glb</code> files.</li> <li>Benefit: \"Real\" modeled plows with proper curves, metallic textures, and baked ambient occlusion.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#2-instanced-rendering-for-gems","title":"2. Instanced Rendering for Gems","text":"<p>The \"Gem Fields\" concept requires high object counts.</p> <ul> <li>Action: Replace individual <code>IcosahedronGeometry</code> meshes with a single <code>THREE.InstancedMesh</code> managed by a specialized <code>GemRenderer</code> system.</li> <li>Benefit: Could easily support 10,000+ gems at 60fps, allowing for massive \"ocean of gems\" gameplay.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#3-decoupled-rendering-state","title":"3. Decoupled Rendering State","text":"<p>Currently, visuals snap to physics state.</p> <ul> <li>Action: Implement a state interpolation buffer. Render at screen refresh rate (e.g., 144Hz) while physics runs at fixed steps (60Hz), interpolating positions <code>(prev * (1-alpha) + curr * alpha)</code>.</li> <li>Benefit: Eliminates micro-stutter and provides buttery smooth motion, even if physics frames drop.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#4-shader-effects","title":"4. Shader Effects","text":"<ul> <li>Action: Replace standard materials with custom ShaderMaterials for effects like \"Glow\" on high-value gems, \"Heat distortion\" behind the engine, or dynamic tracks that fade using a fragment shader time uniform instead of transparency updates.</li> </ul>"},{"location":"archive/SCAD_VS_BLENDER/","title":"Asset Pipeline: OpenSCAD vs. Blender","text":"<p>We originally explored two different pipelines for generating 3D game assets. We have decided to standardize on the Blender pipeline. This document summarizes the differences, benefits, and reasons for this decision.</p>"},{"location":"archive/SCAD_VS_BLENDER/#1-the-openscad-pipeline-programmers-cad","title":"1. The OpenSCAD Pipeline (\"Programmer's CAD\")","text":"<p>Approach:</p> <ul> <li>Define geometry using Constructive Solid Geometry (CSG) in <code>.scad</code> files.</li> <li>Compile to STL -&gt; OBJ -&gt; GLTF using a chain of tools (<code>openscad</code>, <code>obj2gltf</code>).</li> <li>Procedural textures generated at runtime in the client.</li> </ul> <p>Code Snippet (<code>bulldozer_body.scad</code>):</p> <pre><code>// Parametric definition\nbody_width = 12;\nbody_length = 16;\nbody_height = 5;\n\n// CSG Operations\ntranslate([-body_width/2, -body_length/2, 4/2])\n    cube([body_width, body_length, body_height]);\n</code></pre> <p>Pros:</p> <ul> <li>Parametric: Easy to adjust dimensions via variables.</li> <li>Git-Friendly: Source files are pure text.</li> <li>Precise: Exact mathematical alignment.</li> </ul> <p>Cons:</p> <ul> <li>Limited Export: OpenSCAD exports raw geometry (STL) without UVs, Materials, or scene hierarchy.</li> <li>Rendering Issues: The generated meshes often have bad normals or topology for game engines.</li> <li>No Animations: Cannot export armatures, keyframes, or separate parts easily without splitting into many files.</li> <li>Material Complexity: Requires custom \"Triplanar Mapping\" shaders in the client because the model lacks UV coordinates.</li> </ul>"},{"location":"archive/SCAD_VS_BLENDER/#2-the-blender-pipeline-game-ready-assets","title":"2. The Blender Pipeline (\"Game-Ready Assets\")","text":"<p>Approach:</p> <ul> <li>Use Python scripting inside Blender (<code>bpy</code>) to generate geometry programmatically.</li> <li>Export directly to <code>.glb</code> (GLTF binary) which supports hierarchy, materials, and animations.</li> <li>Use standard Three.js loaders in the client.</li> </ul> <p>Code Snippet (<code>bulldozer.py</code>):</p> <pre><code>import bpy\n\n# Create Mesh\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 1.0))\nbody = bpy.context.object\nbody.name = \"Bulldozer_Body\"\nbody.scale = (2.5, 4.0, 1.5)\n\n# Assign Material\nmat = bpy.data.materials.new(name=\"YellowPaint\")\nbody.data.materials.append(mat)\n\n# Export\nbpy.ops.export_scene.gltf(filepath=\"bulldozer.glb\", export_format='GLB')\n</code></pre> <p>Pros:</p> <ul> <li>Rich Assets: Exports a complete scene with node hierarchy, proper names, and material slots.</li> <li>UV Unwrapping: Can automatically project UVs (<code>bpy.ops.uv.smart_project</code>), allowing standard textures.</li> <li>Animation Support: Capable of baking animations and skeletal rigs.</li> <li>Debugging: The generated file can be opened in Blender GUI for visual inspection.</li> <li>Standard Rendering: Works with standard <code>MeshStandardMaterial</code> without shader hacks.</li> </ul> <p>Cons:</p> <ul> <li>Dependency: Requires Blender to be installed on the build machine.</li> <li>Complexity: The Blender Python API is more complex than SCAD.</li> </ul>"},{"location":"archive/SCAD_VS_BLENDER/#conclusion-why-blender","title":"Conclusion: Why Blender?","text":"<p>We chose the Blender pipeline because it produces Game-Ready Assets. The OpenSCAD pipeline required too much runtime \"patching\" (custom shaders for triplanar mapping, manual material assignment, lack of object hierarchy). The Blender pipeline gives us a standard GLTF file that \"just works\" in Three.js, while still maintaining the benefits of procedural generation via Python scripts.</p>"},{"location":"guide/PROJECT_STRUCTURE/","title":"Project Structure","text":"<p>Last Updated: 2025-05-19</p> <p>The project follows a \"Modern Standard\" structure to separate source code, build pipelines, and developer tools.</p>"},{"location":"guide/PROJECT_STRUCTURE/#directory-layout","title":"Directory Layout","text":"<ul> <li><code>src/</code>: Main Game Source Code.<ul> <li> <code>core/</code>: Engine logic (Game loop, Graphics, Physics, UI).</li> <li> <code>entities/</code>: Game Objects (Bulldozer, Gems, Map).</li> <li> <code>utils/</code>: Shared utilities (Math, Graphics).</li> </ul> </li> <li><code>pipeline/</code>: The Asset Factory (\"Source of Truth\").<ul> <li> <code>blender/</code>: Python scripts for geometry generation.</li> <li> <code>textures/</code>: Python scripts for procedural texture generation.</li> <li> <code>scripts/</code>: Node.js build and verification scripts.</li> </ul> </li> <li><code>tools/</code>: Developer Tools.<ul> <li> <code>viewer/</code>: The DAMP Asset Director (Web App).</li> <li> <code>physics-playground/</code>: Isolated physics testing environment.</li> </ul> </li> <li><code>assets/</code>: Source configuration for assets.<ul> <li> <code>configs/</code>: JSON configuration files for the pipeline.</li> </ul> </li> <li><code>docs/</code>: Project Documentation.</li> <li><code>dist/</code>: (Generated) Build artifacts, including compiled assets and the playable game.</li> </ul>"},{"location":"guide/PROJECT_STRUCTURE/#key-workflows","title":"Key Workflows","text":""},{"location":"guide/PROJECT_STRUCTURE/#setup","title":"Setup","text":"<p>Ensure you have <code>uv</code> and <code>go-task</code> installed (handled by <code>.julesrc</code> in dev container).</p>"},{"location":"guide/PROJECT_STRUCTURE/#commands","title":"Commands","text":"Run Build Command Description <code>task dev</code> Starts the main game server locally. <code>task damp:viewer</code> Starts the Asset Viewer tool. Command Description <code>task build:assets</code> Runs the full Blender pipeline to generate GLBs and textures. <code>task build:dist</code> Creates a production build in <code>dist/</code>. <code>task docs:build</code> Builds this documentation site."},{"location":"guide/game_design_principles/","title":"Game Design Principles","text":"<p>Philosophy</p> <p>This document captures the core design philosophies for this project. When making decisions, refer to these principles to ensure the game \"feels\" right.</p>"},{"location":"guide/game_design_principles/#1-the-juice-game-feel","title":"1. The \"Juice\" (Game Feel)","text":"<p>\"Juice\" is the tactile feedback that makes interaction satisfying.</p> <ul> <li>Everything Reacts: When an object is touched, collected, or bought, it must react. (Particles, floating text, sound, scale bounce).</li> <li>Instant Feedback: Never delay the visual result of an action. If a gem is collected, it disappears this frame, even if the logic takes longer.</li> <li>Exaggeration: Realism is secondary to clarity. A 10% upgrade should look like a 10% upgrade, but a Level 10 bulldozer should look absurdly powerful compared to Level 1.</li> </ul>"},{"location":"guide/game_design_principles/#2-progression-pacing","title":"2. Progression &amp; Pacing","text":"<ul> <li>The Power Fantasy: The player starts weak and slow. The goal is to make them feel unstoppable by the end.</li> <li>Micro-Goals: The player should always have a goal reachable within 1-2 minutes (e.g., \"Buy next Engine level\").</li> <li>Macro-Goals: The player needs a horizon goal (e.g., \"Unlock the Red Zone\").</li> <li>Friction vs. Flow:</li> <li>Friction (Slow movement, walls) makes the Flow (Speed upgrades, breaking through) satisfying.</li> <li>Do not remove all friction too early.</li> </ul>"},{"location":"guide/game_design_principles/#3-clarity-readability","title":"3. Clarity &amp; Readability","text":"<ul> <li>Form Follows Function: A \"Collector\" should look like it collects things (funnels, belts). A \"Shop\" should look like a place of transaction.</li> <li>Visual Hierarchy: The most important elements (The Player, The Gems) must contrast with the background.</li> <li>Numbers: Keep numbers readable. \"1.5k\" is better than \"1500\" in tight UI, but precise numbers feel more \"RPG-like\" in stats panels.</li> </ul>"},{"location":"guide/game_design_principles/#4-engineering-for-design","title":"4. Engineering for Design","text":"<ul> <li>Exposed Knobs: Design systems with \"Knobs\" (Constants, Configs) that can be tweaked without rewriting logic.</li> <li>Iterative Balance: Balance is never done. Build tools (like the Asset Viewer or Debug Consoles) that help us \"feel\" the values.</li> <li>Separation of Logic and Visuals: The physics simulation (Matter.js) is the \"Truth\", but the Visuals (Three.js) are the \"Experience\". It's okay to cheat visuals (e.g., floating coins) to make it look good.</li> </ul>"},{"location":"guide/game_design_principles/#5-next-steps-for-better-design","title":"5. Next Steps for \"Better\" Design","text":"<ul> <li>Sound: Currently missing. Sound is 50% of the \"Juice\".</li> <li>Save/Load: Progression is meaningless if lost on refresh.</li> <li>Victory Lap: After winning, give the player a \"Toy\" (e.g., infinite speed, sandbox mode) to enjoy their power.</li> </ul>"},{"location":"history/GEMINI_2025_12/","title":"Gemini Session Summary: DAMP Pipeline Evolution","text":"<p>This document tracks the key technical findings, architectural decisions, and critical \"NO\" moments (course corrections) during the development of the Distributed Asset &amp; Material Pipeline (DAMP).</p>"},{"location":"history/GEMINI_2025_12/#the-core-achievement-the-explicit-contract","title":"\ud83d\ude80 The Core Achievement: The Explicit Contract","text":"<p>We successfully transitioned from an Implicit Pipeline (guessing mesh names like <code>Cube001</code>) to an Explicit Contract Model.</p> <ul> <li>Blender explicitly tags materials and objects with <code>damp_id</code>.</li> <li>JSON defines properties using those IDs.</li> <li>Renderer strictly enforces the contract (ID or Magenta Error).</li> </ul>"},{"location":"history/GEMINI_2025_12/#key-technical-findings","title":"\ud83d\udee0 Key Technical Findings","text":""},{"location":"history/GEMINI_2025_12/#1-parenting-joining","title":"1. Parenting &gt; Joining","text":"<ul> <li>Discovery: <code>bpy.ops.object.join()</code> in Blender destroys Object-level metadata and forces Three.js to split primitives at runtime, causing race conditions.</li> <li>Solution: Use Parenting. It preserves the logical hierarchy, keeps unique names/IDs intact, and allows for independent material tuning without complex \"heuristic\" code.</li> </ul>"},{"location":"history/GEMINI_2025_12/#2-material-level-tagging","title":"2. Material-Level Tagging","text":"<ul> <li>Discovery: Custom properties on Materials are more resilient than on Objects. Even if geometry is merged, Three.js preserves material slots.</li> <li>Impact: Tagging materials directly (<code>MAT_Glass[\"damp_id\"] = \"cabin\"</code>) eliminated 50+ lines of brittle string-matching code in the renderer.</li> </ul>"},{"location":"history/GEMINI_2025_12/#4-the-four-pillars-layout","title":"4. The \"Four Pillars\" Layout","text":"<ul> <li>Discovery: Keeping source, build tools, and distribution assets in a flat or overlapping structure leads to deployment risks and high cognitive load.</li> <li>Solution: Standardize on a Domain-Split structure: <code>src/</code> (App), <code>pipeline/</code> (Factory), <code>tools/</code> (DX), and <code>assets/</code> (Output). This isolates the \"Source of Truth\" from the \"Distribution Artifacts.\"</li> </ul>"},{"location":"history/GEMINI_2025_12/#5-explicit-relative-paths-bare-specifiers","title":"5. Explicit Relative Paths &gt; Bare Specifiers","text":"<ul> <li>Discovery: Relying on <code>importmap</code> for internal project modules (like <code>core/</code>) makes the codebase brittle and harder to debug in standard environments without custom server configs.</li> <li>Solution: Use standard relative paths (<code>./</code>, <code>../</code>) for all internal modules. Save the <code>importmap</code> for external CDN-hosted dependencies (Three.js, React).</li> </ul>"},{"location":"history/GEMINI_2025_12/#the-no-wall-critical-corrections","title":"\ud83d\uded1 The \"NO\" Wall: Critical Corrections","text":"<p>Significant moments where the user rejected a path, leading to a better architecture.</p> <ol> <li>NO to Local Libs: I initially tried to bundle Three.js locally in the viewer.<ul> <li>Correction: \"We switched to unpkg.\"</li> <li>Lesson: Keep the repo lean; use CDNs for standardized dependencies.</li> </ul> </li> <li>NO to \"One-Size-Fits-All\" Texturing: I initially applied one texture to the whole GLB.<ul> <li>Correction: \"Our actual bulldozer uses different textures per component.\"</li> <li>Lesson: The pipeline must support granular, component-level material mapping.</li> </ul> </li> <li>NO to Manual Scaling: I tried to fix alignment by manually setting scales/positions in JS.<ul> <li>Correction: This resulted in \"tiny bodies and giant tracks.\"</li> <li>Lesson: Bake transforms in the source (Blender). Vertices should be normalized at <code>(1,1,1)</code> before export.</li> </ul> </li> <li>NO to Heuristic Fallbacks: I added <code>if (name.includes(\"Cube\"))</code> to handle Blender's generic names.<ul> <li>Correction: \"Don't use fallbacks at all. Use IDs or error.\"</li> <li>Lesson: Reliability comes from explicit contracts, not clever guessing.</li> </ul> </li> <li>NO to Lazy Refactoring: I used <code>// ... logic here</code> placeholders in a file write.<ul> <li>Correction: \"Please don't use '... this logic' when making edit changes.\"</li> <li>Lesson: Always provide complete, functional source code.</li> </ul> </li> <li>NO to Internal Import Maps: I tried to map <code>core/</code> and <code>entities/</code> via <code>importmap</code> to \"fix\" the structure split.<ul> <li>Correction: \"Let's whack a mole the errors independently.\"</li> <li>Lesson: Don't mask path issues with specifier mappings; fix the source imports to use standard relative paths.</li> </ul> </li> <li>NO to \"Summary First\" Workflow: I summarized changes multiple times before actually calling the tool to apply them.<ul> <li>Correction: \"Apply changes to the file and THEN summarise your changes.\"</li> <li>Lesson: The tool call is the primary action; the text output is the confirmation of that action.</li> </ul> </li> </ol>"},{"location":"history/GEMINI_2025_12/#maintainability-checklist","title":"\ud83c\udfd7 Maintainability Checklist","text":"<ul> <li> Modular Build: 5-step process orchestrated by Taskfile.</li> <li> Asset Isolation: Textures and models separated from core game logic.</li> <li> Clean Pillar Split: Source, Pipeline, Tools, and Assets isolated in the filesystem.</li> <li> Standard Imports: Pure relative module resolution without specifier hacks.</li> <li> Verification: <code>task build:verify</code> provides a raw look at the GLB \"Contract\" before it hits the web.</li> <li> Zero-Cache: Dynamic import maps and server headers ensure the latest code is always live.</li> </ul> <p>Session Date: Thursday 18 December 2025</p>"},{"location":"planning/progression_analysis/","title":"Progression Analysis (Current State)","text":"<p>Metadata</p> <p>* Date: 2024-10-25 * Version: 1.0 * Scope: Current values for costs, entity stats, and economy.</p> <p>Context</p> <p>This document outlines the current mathematical models governing the game's progression, including upgrade costs, entity scaling, and economic availability.</p>"},{"location":"planning/progression_analysis/#1-economy-gems","title":"1. Economy (Gems)","text":"<p>The game world is divided into three zones. Gems are the sole source of currency.</p> Zone Gems Value Range Avg Value Zone Total (Approx) Unlock Condition 1 400 8 - 12 10 $4,000 Start 2 400 25 - 40 32.5 $13,000 50% of Zone 1 Collected 3 400 60 - 100 80 $32,000 50% of Zone 2 Collected Total 1200 ~$49,000 <ul> <li>Victory Condition: Collect all gems in the world.</li> <li>Gate Logic: \"Area Level\" controls physical gates.</li> <li>Area Lvl 1 -&gt; 2 (Unlocks Zone 2): Automatically happens when Zone 1 is 50% clear.</li> <li>Area Lvl 2 -&gt; 3 (Unlocks Zone 3): Automatically happens when Zone 2 is 50% clear.</li> </ul>"},{"location":"planning/progression_analysis/#2-upgrade-costs","title":"2. Upgrade Costs","text":"<p>All upgrades follow a simple exponential growth curve: <code>NewCost = floor(OldCost * 1.5)</code>.</p> Upgrade Base Cost Growth Cost @ Lvl 5 Cost @ Lvl 10 Engine 100 x1.5 506 3,844 Plow 100 x1.5 506 3,844 Collector 150 x1.5 759 5,766 <ul> <li>Area Unlock (Manual):</li> <li>The <code>shop.js</code> code contains logic for purchasing \"Unlock Gate\", but <code>gem.js</code> also contains logic for automatic unlocking based on progress.</li> <li>There appears to be a dual-system (Purchase vs Auto). Currently, the \"Unlock Gate\" pad exists but might be redundant if auto-unlock triggers first.</li> <li>Manual Cost: 500 (Lvl 2), 2000 (Lvl 3).</li> </ul>"},{"location":"planning/progression_analysis/#3-entity-scaling","title":"3. Entity Scaling","text":""},{"location":"planning/progression_analysis/#bulldozer-engine","title":"Bulldozer (Engine)","text":"<ul> <li>Base Speed Factor: <code>0.002</code></li> <li>Growth: <code>+0.0005</code> per level (Linear).</li> <li>Turn Speed: <code>0.04</code> (Constant).</li> <li>Effect: A Level 10 dozer moves ~3.25x faster than Level 1.</li> </ul>"},{"location":"planning/progression_analysis/#plow","title":"Plow","text":"<ul> <li>Base Width: <code>45</code> units (Physically scaled x10 -&gt; 450px).</li> <li>Growth: <code>+5</code> units per level.</li> <li>Depth: <code>10</code> units (Constant).</li> <li>Effect: Level 10 plow is double the width of Level 1 (Base 45 + 45 = 90).</li> </ul>"},{"location":"planning/progression_analysis/#collector","title":"Collector","text":"<ul> <li>Base Body: Circle, Radius <code>30 + (Level * 5)</code> (Diameter <code>60 + 10*Lvl</code>).</li> <li>Belts (Lvl &gt; 1):</li> <li>Length: <code>50 + (Level - 2) * 50</code> (Capped at 500).</li> <li>Width: <code>60 + floor((Level - 2) / 2) * 20</code>.</li> <li>Top Belt: Added at Level 4.</li> <li>Effect: Significantly increases catchment area starting at Level 2.</li> </ul>"},{"location":"planning/progression_analysis/#4-analysis","title":"4. Analysis","text":"<ul> <li>Total Money Cap: With ~$49,000 total in the world, the player effectively hits a \"Soft Cap\" on upgrades around Level 12-13 for a single item, or Level 9-10 spread across all three.</li> <li>Pacing: The exponential cost curve means early upgrades are frequent, but late game upgrades become grindy.</li> <li>Redundancy: The \"Buy Area\" shop pad conflicts with the \"Auto Unlock\" mechanic in <code>gem.js</code>.</li> </ul>"},{"location":"planning/roadmap/","title":"Roadmap","text":""},{"location":"planning/roadmap/#active-work","title":"Active Work","text":"<ul> <li> Documentation Rewrite: Full audit and restructure of project documentation to reflect current state. (View Plan)</li> <li> UI &amp; Gameplay Polish: Replaced physical \"Money Mat\" with flying coin UI animation and fixed collector upgrade scaling. (View Plan)</li> </ul>"},{"location":"planning/roadmap/#backlog","title":"Backlog","text":"<ul> <li> Asset Pipeline Optimization: Further refinements to the Blender -&gt; GLB pipeline.</li> <li> Gameplay Features: Additional upgrades and levels.</li> <li> Mobile Optimization: Improve touch controls and performance on mobile devices.</li> </ul>"},{"location":"planning/task_scaling_rebalance/","title":"Task: Scaling Rebalance &amp; Progression Tuning","text":"<p>Metadata</p> <p>* Status: Proposed * Type: Rebalance / Feature * Dependencies: <code>docs/planning/progression_analysis.md</code></p> <p>Objective</p> <p>Refine the game's progression curve to ensure a satisfying \"Power Fantasy\" loop while maintaining challenge. Resolve the conflict between manual and automatic area unlocking.</p> <p>Plan</p> <p>1. Resolve Unlock Logic * Remove the \"Auto Unlock\" feature from <code>gem.js</code>. Making area unlocks a deliberate Purchase Decision creates a stronger short-term goal for the player (\"I need 500 gold to open the gate\"). * Keep the Zone Progress notification but change the reward to a large \"Bonus Cash\" drop or simply a \"Zone Clear\" badge.</p> <pre><code>2.  **Tune Economy (Inflation)**\n    *   Current Total: ~$50k.\n    *   Target Total: ~$100k.\n    *   Action: Increase Gem Values in Zone 3 (Make them \"Big Ticket\" items, 100-200 value).\n    *   This supports a few more high-level upgrades (Levels 12-15).\n\n3.  **Adjust Upgrade Curves**\n    *   **Engine:** The linear speed increase is good, but maybe start slightly faster? Base `0.0025`.\n    *   **Plow:** Increase width scaling slightly. `+8` per level instead of `+5`. Players love seeing the plow get massive.\n    *   **Collector:**\n        *   Level 1 is very weak (small circle).\n        *   Make Level 1 slightly larger.\n        *   Ensure Belts visual scaling matches physics scaling (currently procedural).\n\n4.  **Cost Curve Smoothing**\n    *   The `x1.5` curve is harsh.\n    *   Proposal: Change to `Cost = Base * (1.3 ^ (Level - 1))`.\n    *   Comparison (Base 100):\n        *   Lvl 5: x1.5 -&gt; 506 | x1.3 -&gt; 285\n        *   Lvl 10: x1.5 -&gt; 3844 | x1.3 -&gt; 1060\n        *   Lvl 15: x1.5 -&gt; 29k | x1.3 -&gt; 3900\n    *   This allows players to reach higher levels (15-20) where the visual upgrades (massive plow, complex belts) are most satisfying.\n\n5.  **Visual Feedback**\n    *   Ensure the \"Next Upgrade Cost\" is clearly visible *before* purchase (currently displayed on the pad?).\n    *   Add a visual indicator when an upgrade is affordable (e.g., Pad glows green).\n</code></pre> <p>Execution Log</p> <p>* [ ] Remove auto-unlock from <code>src/entities/gem.js</code>. * [ ] Update <code>src/entities/shop.js</code> to ensure Gate Unlock costs are balanced (500, 2500?). * [ ] Update <code>src/core/state.js</code> costs logic to use <code>1.3</code> multiplier. * [ ] Tweak <code>src/entities/bulldozer.js</code> stats.</p>"},{"location":"planning/ui_gameplay_polish/","title":"Plan: UI &amp; Gameplay Polish","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2026-01-07</li> <li>Author: Jules (AI Agent)</li> </ul> <p> Context</p> <p>The project required several refinements to improve visual polish and fix gameplay bugs. Specifically: 1.  Money Mat: The physical \"mat\" and 3D coin piles were causing visual clutter and were deemed unnecessary. 2.  Coin Animation: A more engaging visual feedback for currency collection was requested, specifically animating \"flying coins\" to the UI counter. 3.  Collector Upgrade: The collector logic scaled exponentially, causing the entity to extend infinitely and clip through map walls at high levels.</p> <p> Plan</p> <ol> <li>Remove Money Mat: Delete <code>createCoinPile</code>, <code>updateCoinPile</code>, and related groups from <code>src/core/graphics.js</code>.</li> <li>UI Animation: Implement <code>spawnCoinDrop</code> using DOM elements (<code>.flying-coin</code>) and the Web Animations API to animate coins from world-space to the <code>#money</code> UI element.</li> <li>Collector Fix: Refactor <code>src/entities/collector.js</code> to use linear scaling (<code>50 + (level-2)*50</code>) and cap the length at 500 units.</li> <li>Verification: Add a Playwright script to verify the visual changes.</li> </ol> <p> Execution Log</p> <ul> <li> Cleanup: Removed <code>coinPileGroup</code> and related logic from <code>src/core/graphics.js</code>.</li> <li> Animation: Implemented DOM-based flying coin animation in <code>spawnCoinDrop</code>.</li> <li> Styling: Added <code>.flying-coin</code> class to <code>style.css</code>.</li> <li> Fix: Updated <code>src/entities/collector.js</code> to cap belt length and use linear growth.</li> <li> Verification: Verified via <code>verification/verify_changes.py</code> (flying coins detected).</li> </ul> <p> AI Summary</p> <p>The tasks were successfully completed. The removal of the 3D money pile reduces scene complexity, while the new flying coin animation provides clear, satisfying feedback for the player. The collector upgrade logic is now robust against map boundary clipping.</p>"},{"location":"planning/archive/2025-05-18_refactoring/","title":"Current Plan: Refactoring &amp; Docs","text":"<p>Date: 2025-05-18 (Session Date)</p>"},{"location":"planning/archive/2025-05-18_refactoring/#overview","title":"Overview","text":"<p>We are solidifying the DAMP pipeline and improving project documentation infrastructure.</p>"},{"location":"planning/archive/2025-05-18_refactoring/#changes","title":"Changes","text":""},{"location":"planning/archive/2025-05-18_refactoring/#1-code-maintenance","title":"1. Code Maintenance","text":"<ul> <li>Consolidated <code>cb()</code> Utility: Moved the cache-busting function from scattered files to <code>src/utils/graphics-utils.js</code>.</li> <li>Blender Parenting: Refactored <code>pipeline/blender/bulldozer.py</code> to use object parenting instead of mesh joining. This ensures that individual components (Wheels, Cabin) retain their <code>damp_id</code> contract tags in the exported GLB.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/#2-documentation-system","title":"2. Documentation System","text":"<ul> <li>MkDocs: Setting up <code>mkdocs</code> with the <code>material</code> theme for a professional documentation site.</li> <li>Auto-Formatting: Integrating <code>mdformat</code> to keep documentation consistent.</li> <li>Deployment: Ensuring docs are built and published to <code>dist/docs</code> during PR previews.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/#next-steps","title":"Next Steps","text":"<ul> <li> Verify the new GLB structure in the Asset Viewer.</li> <li> Verify the documentation site build.</li> </ul>"},{"location":"planning/archive/doc_rewrite/","title":"Plan: Documentation Rewrite","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2025-05-19</li> <li>Author: Jules (AI Agent)</li> </ul> <p> Context</p> <p>The project documentation was fragmented, out of date, and lacked a clear structure. The goal of this task was to perform a \"Full Rewrite\" to consolidate information, establish a clear hierarchy, and implement a maintainable roadmap structure. Additionally, we aimed to \"uplift\" the visual presentation using <code>mkdocs-material</code> features like admonitions and tabs.</p> <p> Plan</p> <ol> <li>Consolidate and Clean Up: Remove duplicate files and archive old plans.</li> <li>Restructure: Organize <code>docs/</code> into logical subdirectories (<code>architecture</code>, <code>troubleshooting</code>, <code>history</code>).</li> <li>Update Content: Rewrite key architectural docs (<code>DAMP_MAINTAINABILITY.md</code>) to reflect the current \"Explicit Contract\" state.</li> <li>Enhance: Add <code>mkdocs-material</code> plugins and formatting.</li> <li>Tooling: Add a pre-commit script to enforce documentation formatting.</li> </ol> <p> Execution Log</p> <ul> <li> Restructuring: Moved files to <code>docs/architecture</code>, <code>docs/guide</code>, etc.</li> <li> Roadmap: Created <code>docs/planning/roadmap.md</code> and archived old plans.</li> <li> Rewrite: Completely rewrote <code>DAMP_MAINTAINABILITY.md</code> to remove outdated \"Proposed\" logic.</li> <li> Uplift: Updated <code>mkdocs.yml</code> with <code>awesome-pages</code>, <code>admonition</code>, and <code>pymdownx.emoji</code>.</li> <li> Tooling: Implemented <code>pipeline/scripts/format_docs.py</code> using <code>uvx</code> and <code>mdformat</code> (resolving dependency conflicts by removing <code>mdformat-admon</code>).</li> <li> Verification: Validated build via <code>task docs:build</code>.</li> </ul> <p> AI Summary</p> <p>The documentation ecosystem has been successfully migrated to a structured, maintainable format.</p> <p>Key Achievements:</p> <ul> <li>Architecture: The \"Four Pillars\" structure (Src, Pipeline, Tools, Assets) is now formally documented.</li> <li>Pipeline: The \"Explicit Contract\" model (using <code>damp_id</code>) is codified as the source of truth, replacing old speculative docs.</li> <li>Visuals: Documentation now uses consistent admonitions, tabs for commands, and icons for navigation.</li> <li>Workflow: A new <code>task docs:format</code> command ensures consistency going forward.</li> </ul> <p>Next Steps for Future Agents:</p> <ul> <li>Refer to <code>docs/architecture/DAMP_MAINTAINABILITY.md</code> for architectural decisions.</li> <li>Use <code>docs/planning/roadmap.md</code> to track future work.</li> <li>Ensure all new docs pass <code>task docs:lint</code>.</li> </ul>"},{"location":"troubleshooting/COMMON_ERRORS/","title":"Common Errors &amp; Troubleshooting","text":""},{"location":"troubleshooting/COMMON_ERRORS/#asset-viewer","title":"Asset Viewer","text":""},{"location":"troubleshooting/COMMON_ERRORS/#failed-to-load-resource-script-unknown-source","title":"<code>Failed to load resource: &lt;SCRIPT&gt; unknown source</code>","text":"<p>Symptoms</p> <ul> <li>The asset viewer loads the UI but the 3D scene is empty.</li> <li>The console (or on-screen log) shows \"Failed to load resource\" pointing to the main module script.</li> <li>\"Three.js imported successfully\" is NOT logged.</li> </ul> <p>Cause: This error occurs when the browser cannot resolve one of the JavaScript modules imported by the viewer. Common reasons include:</p> <ol> <li>Incorrect Server Root: The web server was started from the <code>verification/</code> directory instead of the repository root. This makes <code>../js/</code> and <code>../node_modules/</code> inaccessible (404).</li> <li>Missing Dependencies: <code>npm install</code> has not been run, so <code>node_modules</code> is missing or incomplete.</li> <li>Deployment Path Issues: In a deployed environment (e.g., GitHub Pages), the relative paths to <code>js/</code> or <code>node_modules/</code> might be incorrect if the build script didn't rewrite them properly.</li> </ol> <p>Solution</p> <p>Local Development: Use the Taskfile commands to start the viewer from the correct root:</p> <pre><code>task damp:viewer\n</code></pre> <p>Deployment: Check the <code>pr-preview.yml</code> workflow to ensure it copies source files to the <code>dist/</code> folder and rewrites paths (<code>sed</code>) in <code>index.html</code>.</p>"},{"location":"troubleshooting/COMMON_ERRORS/#failed-to-load-resource-bulldozer_componentsglb-404","title":"<code>Failed to load resource: ... bulldozer_components.glb</code> (404)","text":"<p>Cause: The 3D assets have not been built locally.</p> <p>Solution</p> <p>Run the asset build task:</p> <pre><code>task build:assets\n</code></pre> <p>Note: The asset viewer handles this gracefully by logging a warning, but the model will not appear.</p>"},{"location":"troubleshooting/COMMON_ERRORS/#graphics-glitches","title":"Graphics Glitches","text":""},{"location":"troubleshooting/COMMON_ERRORS/#fan-like-vertical-tracks","title":"\"Fan-like\" Vertical Tracks","text":"<p>Cause: The track link mesh orientation in the GLB does not match the animation logic (Three.js <code>lookAt</code> expects Z-forward).</p> <p>Solution</p> <p>Use the \"Track Adj\" controls in the Asset Viewer to set Z-Rotation to 270.</p>"},{"location":"troubleshooting/COMMON_ERRORS/#flickering-vanishing-tracks","title":"Flickering / Vanishing Tracks","text":"<p>Cause: Gimbal lock when the track tangent aligns with the World Y-axis.</p> <p>Solution</p> <p>Ensure the \"Up\" vector in the Asset Viewer is set to X (Axle).</p>"},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/","title":"Graphics Troubleshooting: The \"Striped Shadow\" Artifact","text":""},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-issue","title":"The Issue","text":"<p>In 3D rendering, you may observe weird, striped shadow patterns across surfaces that look like texture glitches or blinds. This is often described as \"Shadow Acne\" or \"Self-Shadowing Artifacts.\"</p>"},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-cause","title":"The Cause","text":"<p>This is a fundamental limitation of Shadow Mapping.</p> <ol> <li>Depth Map Resolution: The light source renders the scene depth to a texture (the Shadow Map). This texture has limited resolution (e.g., 1024x1024 pixels).</li> <li>Quantization: When checking if a pixel on the screen is in shadow, the engine compares the pixel's depth to the value stored in the shadow map.</li> <li>The Glitch: Due to limited precision (quantization) and the angle of the light, a flat surface might calculate its depth as slightly behind the value in the shadow map for some pixels and in front for others. This causes the surface to cast a shadow on itself in a striped pattern.</li> </ol>"},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-fix","title":"The Fix","text":"<p>We need to tune the Shadow Bias.</p>"},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/#1-bias-offset","title":"1. Bias (Offset)","text":"<p>This pushes the shadow slightly deeper/away from the light.</p> <ul> <li>Too Low: Acne remains.</li> <li>Too High: \"Peter Panning\" (shadows detach from the object).</li> </ul>"},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/#2-normal-bias","title":"2. Normal Bias","text":"<p>This pushes the shadow lookup coordinate along the surface normal. This is very effective for curved or low-poly geometry (like our programmer art).</p>"},{"location":"troubleshooting/GRAPHICS_TROUBLESHOOTING/#implementation-in-threejs","title":"Implementation in Three.js","text":"<pre><code>const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\ndirLight.castShadow = true;\n\n// The Fix:\ndirLight.shadow.bias = -0.0005;      // Slight offset to remove acne\ndirLight.shadow.normalBias = 0.05;   // Pushes shadow based on surface angle\n</code></pre> <p>We have applied this fix to <code>asset_viewer.html</code>.</p>"}]}