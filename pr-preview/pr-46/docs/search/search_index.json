{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation Index","text":"<p>Welcome to the Gem Miner technical documentation.</p>"},{"location":"#guides-reference-living","title":"\ud83d\udcda Guides &amp; Reference (Living)","text":"<ul> <li> Project Structure: Overview of the codebase layout, including source, pipeline, and tools.</li> <li> Taskfile Commands: How to build, run, and verify the project.</li> </ul>"},{"location":"#architecture-damp","title":"\ud83c\udfd7 Architecture (DAMP)","text":"<p>The Distributed Asset &amp; Material Pipeline (DAMP) is the core of our asset generation workflow.</p> <ul> <li> Maintainability \"Bible\": The \"Explicit Contract\" model and core pillars.</li> <li> Pipeline Review: Context on the transition to DAMP.</li> <li> Blender Pipeline: How to create assets using our Python API.</li> </ul>"},{"location":"#planning-proposals","title":"\ud83d\uddd3 Planning &amp; Proposals","text":"<ul> <li>:material-roadmap: Roadmap: High-level goals and backlog.</li> <li> Active Task: Agent Playtesting: Planning and implementation tracker for automated testing.</li> <li> Proposal: Agent Playtesting: The original conceptual proposal for agent playtesting.</li> </ul>"},{"location":"#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":"<ul> <li> Common Errors: Setup and runtime issues.</li> <li> Graphics Troubleshooting: Visual artifacts and rendering fixes.</li> </ul>"},{"location":"#history","title":"\ud83d\udd70 History","text":"<ul> <li> History: Past session logs and decision records.</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/","title":"Gemini Session Summary: DAMP Pipeline Evolution","text":"<p>This document tracks the key technical findings, architectural decisions, and critical \"NO\" moments (course corrections) during the development of the Distributed Asset &amp; Material Pipeline (DAMP).</p>"},{"location":"knowledge/history/GEMINI_2025_12/#the-core-achievement-the-explicit-contract","title":"\ud83d\ude80 The Core Achievement: The Explicit Contract","text":"<p>We successfully transitioned from an Implicit Pipeline (guessing mesh names like <code>Cube001</code>) to an Explicit Contract Model.</p> <ul> <li>Blender explicitly tags materials and objects with <code>damp_id</code>.</li> <li>JSON defines properties using those IDs.</li> <li>Renderer strictly enforces the contract (ID or Magenta Error).</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#key-technical-findings","title":"\ud83d\udee0 Key Technical Findings","text":""},{"location":"knowledge/history/GEMINI_2025_12/#1-parenting-joining","title":"1. Parenting &gt; Joining","text":"<ul> <li>Discovery: <code>bpy.ops.object.join()</code> in Blender destroys Object-level metadata and forces Three.js to split primitives at runtime, causing race conditions.</li> <li>Solution: Use Parenting. It preserves the logical hierarchy, keeps unique names/IDs intact, and allows for independent material tuning without complex \"heuristic\" code.</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#2-material-level-tagging","title":"2. Material-Level Tagging","text":"<ul> <li>Discovery: Custom properties on Materials are more resilient than on Objects. Even if geometry is merged, Three.js preserves material slots.</li> <li>Impact: Tagging materials directly (<code>MAT_Glass[\"damp_id\"] = \"cabin\"</code>) eliminated 50+ lines of brittle string-matching code in the renderer.</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#4-the-four-pillars-layout","title":"4. The \"Four Pillars\" Layout","text":"<ul> <li>Discovery: Keeping source, build tools, and distribution assets in a flat or overlapping structure leads to deployment risks and high cognitive load.</li> <li>Solution: Standardize on a Domain-Split structure: <code>src/</code> (App), <code>pipeline/</code> (Factory), <code>tools/</code> (DX), and <code>assets/</code> (Output). This isolates the \"Source of Truth\" from the \"Distribution Artifacts.\"</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#5-explicit-relative-paths-bare-specifiers","title":"5. Explicit Relative Paths &gt; Bare Specifiers","text":"<ul> <li>Discovery: Relying on <code>importmap</code> for internal project modules (like <code>core/</code>) makes the codebase brittle and harder to debug in standard environments without custom server configs.</li> <li>Solution: Use standard relative paths (<code>./</code>, <code>../</code>) for all internal modules. Save the <code>importmap</code> for external CDN-hosted dependencies (Three.js, React).</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#the-no-wall-critical-corrections","title":"\ud83d\uded1 The \"NO\" Wall: Critical Corrections","text":"<p>Significant moments where the user rejected a path, leading to a better architecture.</p> <ol> <li>NO to Local Libs: I initially tried to bundle Three.js locally in the viewer.<ul> <li>Correction: \"We switched to unpkg.\"</li> <li>Lesson: Keep the repo lean; use CDNs for standardized dependencies.</li> </ul> </li> <li>NO to \"One-Size-Fits-All\" Texturing: I initially applied one texture to the whole GLB.<ul> <li>Correction: \"Our actual bulldozer uses different textures per component.\"</li> <li>Lesson: The pipeline must support granular, component-level material mapping.</li> </ul> </li> <li>NO to Manual Scaling: I tried to fix alignment by manually setting scales/positions in JS.<ul> <li>Correction: This resulted in \"tiny bodies and giant tracks.\"</li> <li>Lesson: Bake transforms in the source (Blender). Vertices should be normalized at <code>(1,1,1)</code> before export.</li> </ul> </li> <li>NO to Heuristic Fallbacks: I added <code>if (name.includes(\"Cube\"))</code> to handle Blender's generic names.<ul> <li>Correction: \"Don't use fallbacks at all. Use IDs or error.\"</li> <li>Lesson: Reliability comes from explicit contracts, not clever guessing.</li> </ul> </li> <li>NO to Lazy Refactoring: I used <code>// ... logic here</code> placeholders in a file write.<ul> <li>Correction: \"Please don't use '... this logic' when making edit changes.\"</li> <li>Lesson: Always provide complete, functional source code.</li> </ul> </li> <li>NO to Internal Import Maps: I tried to map <code>core/</code> and <code>entities/</code> via <code>importmap</code> to \"fix\" the structure split.<ul> <li>Correction: \"Let's whack a mole the errors independently.\"</li> <li>Lesson: Don't mask path issues with specifier mappings; fix the source imports to use standard relative paths.</li> </ul> </li> <li>NO to \"Summary First\" Workflow: I summarized changes multiple times before actually calling the tool to apply them.<ul> <li>Correction: \"Apply changes to the file and THEN summarise your changes.\"</li> <li>Lesson: The tool call is the primary action; the text output is the confirmation of that action.</li> </ul> </li> </ol>"},{"location":"knowledge/history/GEMINI_2025_12/#maintainability-checklist","title":"\ud83c\udfd7 Maintainability Checklist","text":"<ul> <li> Modular Build: 5-step process orchestrated by Taskfile.</li> <li> Asset Isolation: Textures and models separated from core game logic.</li> <li> Clean Pillar Split: Source, Pipeline, Tools, and Assets isolated in the filesystem.</li> <li> Standard Imports: Pure relative module resolution without specifier hacks.</li> <li> Verification: <code>task build:verify</code> provides a raw look at the GLB \"Contract\" before it hits the web.</li> <li> Zero-Cache: Dynamic import maps and server headers ensure the latest code is always live.</li> </ul> <p>Session Date: Thursday 18 December 2025</p>"},{"location":"knowledge/legacy/ASSET_PIPELINE/","title":"Asset Pipeline &amp; Material Challenges","text":""},{"location":"knowledge/legacy/ASSET_PIPELINE/#current-architecture","title":"Current Architecture","text":"<p>Our \"Programmer CAD\" pipeline currently operates as follows:</p> <ol> <li>Source: Parametric geometry defined in OpenSCAD (<code>.scad</code>).</li> <li>Compilation: OpenSCAD CLI exports the geometry to ASCII STL.</li> <li>Conversion: A custom script (<code>stl2obj.js</code>) converts STL to OBJ.</li> <li>Packaging: <code>obj2gltf</code> converts OBJ to binary GLTF (<code>.glb</code>).</li> </ol>"},{"location":"knowledge/legacy/ASSET_PIPELINE/#implemented-strategy-component-based-assembly","title":"Implemented Strategy: Component-Based Assembly","text":"<p>To solve the \"monolithic mesh\" color limitation of STL, we have adopted a Component-Based Assembly strategy.</p> <ul> <li>Workflow:<ul> <li>Instead of one <code>bulldozer.scad</code>, we maintain separate source files:<ul> <li><code>bulldozer_body.scad</code></li> <li><code>bulldozer_tracks.scad</code></li> <li><code>bulldozer_cabin.scad</code></li> </ul> </li> <li>The build pipeline (<code>npm run build:assets</code>) compiles these individually into <code>.glb</code> files.</li> </ul> </li> <li>Runtime Assembly:<ul> <li>The game engine (Three.js) loads these separate assets.</li> <li>They are added to a single <code>THREE.Group</code> container.</li> <li>Colors/Materials: Because each part is a distinct mesh, we can assign different materials to them programmatically (e.g., <code>bodyMesh.material = yellowMaterial</code>, <code>tracksMesh.material = darkMaterial</code>).</li> </ul> </li> </ul>"},{"location":"knowledge/legacy/ASSET_PIPELINE/#future-roadmap-advanced-visuals-best-practices","title":"Future Roadmap: Advanced Visuals &amp; Best Practices","text":"<p>As we look to move beyond simple solid colors, here are the challenges and best practices for a \"Programmer CAD\" (Code-first) workflow vs. a traditional Artist workflow.</p>"},{"location":"knowledge/legacy/ASSET_PIPELINE/#1-textures-surface-detail","title":"1. Textures &amp; Surface Detail","text":"<p>The Challenge: Standard 3D texturing relies on UV Mapping\u2014unwrapping a 3D object onto a 2D plane so an image can be painted on it. OpenSCAD / CSG (Constructive Solid Geometry) tools do not generate UV maps automatically, and \"unwrapping\" a procedurally generated mesh manually defeats the purpose of an automated pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Triplanar Mapping: Instead of using UVs, use a special shader (or Three.js node material) that projects textures onto the object from the Top, Front, and Side (X, Y, Z axes). This allows you to apply \"Dirt\", \"Rust\", or \"Scratches\" textures to any shape without manual work.</li> <li>Matcaps (Material Capture): Use <code>THREE.MeshMatcapMaterial</code>. This uses a spherical reference image to fake complex lighting and reflection (e.g., chrome, shiny car paint) cheaply. It looks great and requires no UVs.</li> <li>Decals: For specific details (like a \"Hazard Stripe\" or a Logo), use a separate floating mesh or a \"Decal\" geometry placed slightly above the surface, rather than trying to texture the main body.</li> </ul>"},{"location":"knowledge/legacy/ASSET_PIPELINE/#2-animations","title":"2. Animations","text":"<p>The Challenge: Traditional game assets use \"Skinned Meshes\" (bones/skeletons) to deform geometry (e.g., a character bending their arm). OpenSCAD exports static rigid meshes. We cannot easily add \"bones\" to an STL file in this pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Hierarchical / Rigid Body Animation: This is what we already support with the Component-Based Assembly.<ul> <li>Example: To animate the plow moving up and down, we do not bend the metal. We verify the <code>plow.glb</code> is its own object, and in the game code, we change its <code>position.y</code> or <code>rotation.x</code>.</li> <li>Example: To animate tracks, we don't deform the rubber. We scroll the texture on the tracks (UV offset animation) or rotate the wheels if they are separate parts.</li> </ul> </li> <li>Code-Driven Motion: All animation should be driven by game state (physics, input), not pre-baked animation clips (like an <code>.fbx</code> file might have). This gives the \"programmer\" ultimate control.</li> </ul>"},{"location":"knowledge/legacy/ASSET_PIPELINE/#summary-of-programmer-art-stack","title":"Summary of \"Programmer Art\" Stack","text":"Feature Traditional Workflow (Blender/Maya) Our Workflow (OpenSCAD/Three.js) Geometry Hand-modeled polygons Code-defined primitives (CSG) Colors Texture Maps / Vertex Paint Separate Parts / Runtime Materials Textures Manual UV Unwrapping Triplanar Mapping / Matcaps Animation Skeletal Rigging / Keyframes Hierarchical Code Manipulation <p>Next Steps Recommendation:</p> <ol> <li>Stick to solid colors for now to keep the style clean (e.g., \"Low Poly\" aesthetic).</li> <li>If detail is needed, explore Triplanar Mapping shaders to add noise/grit without needing asset changes.</li> <li>For the plow animation, ensure the plow is a separate asset from the body so it can be moved independently in code.</li> </ol>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/","title":"Tutorial: The Bulldozer Renderer","text":""},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#1-the-high-level-goal","title":"1. The High-Level Goal","text":"<p>This file is responsible for:</p> <ol> <li>Loading the 3D model of the bulldozer.</li> <li>Painting it (creating textures via code, so no image files are needed).</li> <li>Animating the tank tracks so they look like they are rolling.</li> <li>Syncing the visual position with the physics body (Matter.js).</li> </ol>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#2-generating-textures-procedurally","title":"2. Generating Textures \"Procedurally\"","text":"<p>Instead of loading JPG or PNG images (which takes time and bandwidth), this code \"draws\" its own textures using a virtual HTML Canvas.</p> <p>Function: <code>createProceduralTexture(type)</code></p> <ul> <li>How it works: It creates a hidden <code>&lt;canvas&gt;</code> element in memory, gets a 2D drawing context (<code>ctx</code>), and draws shapes.</li> <li>The \"Tracks\" Texture: It draws a dark background and then loops to draw chevron/V-shapes. This creates the tread pattern.</li> <li>The \"Body\" Texture: It draws a yellow square, then scatters random noise (dots) and rust spots to make it look like weathered metal.</li> <li>Three.js Conversion: Finally, <code>new THREE.CanvasTexture(canvas)</code> turns that drawing into something the 3D engine can wrap around a shape.</li> </ul> <pre><code>// Example logic simplified:\nif (type === 'tracks') {\n    ctx.fillStyle = '#333';\n    // Draw zig-zag lines for treads...\n}\nreturn new THREE.CanvasTexture(canvas);\n</code></pre>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#3-the-shader-magic-advanced","title":"3. The Shader Magic (Advanced)","text":"<p>Standard 3D models need \"UV Maps\" (instructions on how to wrap a 2D image around a 3D object). This file uses a clever trick called Triplanar Mapping to avoid needing perfect UVs.</p> <p>Function: <code>enhanceMaterialWithTriplanar(...)</code></p> <ul> <li>What is a Shader? A shader is a small program that runs on your Graphics Card (GPU) to decide the color of every single pixel.</li> <li>The Trick: It intercepts the standard Three.js material code (<code>onBeforeCompile</code>) and injects custom logic.</li> <li>Triplanar Logic: Instead of stretching a texture, it projects the texture from three directions (Top, Side, Front) and blends them together.</li> <li>Scrolling: For the tracks, it adds a <code>uTime</code> variable to slide the texture coordinates, making the treads look like they are moving without actually moving the geometry.</li> </ul>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#4-the-main-class-bulldozerrenderer","title":"4. The Main Class: <code>BulldozerRenderer</code>","text":""},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-constructor","title":"The Constructor","text":"<p>When <code>new BulldozerRenderer(scene)</code> is called:</p> <ol> <li>It creates a <code>THREE.Group</code>. Think of this as an invisible box that will hold all the bulldozer parts (body, glass, tracks).</li> <li>It creates a <code>GLTFLoader</code>. This is the tool that knows how to read <code>.glb</code> (3D model) files.</li> <li>It prepares empty lists (<code>animatedInstances</code>) to track things that need to move every frame.</li> </ol>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-loadurl-method","title":"The <code>load(url)</code> method","text":"<p>This is the heavy lifter. It fetches the file and organizes the parts.</p> <ol> <li>Finding Parts: It loops through every object in the 3D file:<ul> <li>If the name contains \"Bulldozer_Body\", it keeps it as the chassis.</li> <li>If the name contains \"Asset_TrackLink\", it keeps track of track link to load.</li> <li>If the name contains \"Asset_TrackPath\", it reads the mathematical points to know the shape of the tracks (oval-ish).</li> </ul> </li> <li>Applying Materials: It creates the shiny glass material and the rough metal material (using the procedural textures from step 2).</li> <li>Building Tracks (InstancedMesh):<ul> <li>Instead of creating 50 separate 3D objects for the track links (which is slow), it uses <code>InstancedMesh</code>.</li> <li>This tells the GPU: \"Draw this one shape 50 times at these 50 different positions.\" It's a huge performance optimization.</li> <li>It uses <code>THREE.CatmullRomCurve3</code> to calculate a smooth path along the points found in the file.</li> </ul> </li> </ol>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-setposeposition-angle-method","title":"The <code>setPose(position, angle)</code> method","text":"<p>This is the bridge between the Physics world (Matter.js) and the Visual world (Three.js).</p> <ul> <li>Matter.js (2D) calculates where the box is.</li> <li>Three.js (3D) needs to know where to draw it.</li> <li>This function copies the X/Y from physics to X/Z in 3D (since Y is \"up\" in 3D) and applies the rotation.</li> </ul> <pre><code>setPose(position, angle) {\n    this.group.position.set(position.x, 0, position.y); // Map 2D -&gt; 3D\n    this.group.rotation.y = -angle; // Rotate the model\n}\n</code></pre>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-updatedelta-method","title":"The <code>update(delta)</code> method","text":"<p>This runs 60 times a second (the game loop).</p> <ol> <li>Shader Time: It increases the <code>uTime</code> value so the track textures keep scrolling.</li> <li>Track Movement: It calculates the position of every single track link along the curve.<ul> <li><code>track.curve.getPointAt(t)</code>: \"Where is the link at 50% along the curve?\"</li> <li><code>track.curve.getTangentAt(t)</code>: \"Which way should it face?\"</li> <li>It updates the matrix (position+rotation) for all 50 track links instantly.</li> </ul> </li> </ol>"},{"location":"knowledge/legacy/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#summary","title":"Summary","text":"<ul> <li><code>bulldozer.js</code> is the \"Brain\" (Physics, Collision).</li> <li><code>bulldozer_render.js</code> is the \"Costume\" (Graphics).</li> <li>It generates its own \"fabric\" (textures) via code.</li> <li>It uses a \"Green Screen\" trick (Shaders) to animate the texture scrolling.</li> <li>It listens to the \"Brain\" every frame via <code>setPose</code> to know where to stand.</li> </ul>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/","title":"Graphics System Design &amp; Analysis","text":""},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#current-implementation","title":"Current Implementation","text":"<p>The current graphics implementation relies on a \"Programmer Art\" approach where 3D visuals are generated procedurally at runtime using Three.js primitives (<code>BoxGeometry</code>, <code>TorusGeometry</code>, <code>IcosahedronGeometry</code>).</p>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#architecture","title":"Architecture","text":"<ul> <li>State Synchronization: The <code>updateGraphics()</code> loop iterates through all Matter.js physics bodies every frame.</li> <li>1:1 Mapping: Each physics body part (including compound body parts) creates and manages its own independent Three.js mesh.</li> <li>Procedural Generation: Visuals like the Bulldozer, Plow, and Collector are constructed by combining simple geometric shapes in code. Texture atlases or external models are not used.</li> </ul>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#deviation-from-standard-practices","title":"Deviation from Standard Practices","text":"<p>Industry-standard web game development (using engines like Three.js, Babylon, or PlayCanvas) typically follows different patterns:</p> <ol> <li> <p>Asset-Based Workflow:</p> <ul> <li>Standard: Artists create models in tools like Blender/Maya/3ds Max and export them as <code>GLTF</code>/<code>GLB</code> files. These assets contain optimized geometry, UV maps, materials, and animations.</li> <li>Current: Geometry is hard-coded. Adjusting the \"look\" (e.g., curving a plow) requires complex trigonometric math and geometry manipulation in code rather than moving vertices in an editor.</li> </ul> </li> <li> <p>Scene Graph Hierarchy:</p> <ul> <li>Standard: A single visual root object represents a game entity (e.g., a Tank). Physics bodies update the root's transform, and child nodes (turret, wheels) are animated relative to that root.</li> <li>Current: Every physics sub-part (chassis, wheel, plow) drives its own mesh directly. This ensures tight physics matching but makes complex visual articulation (like suspension or smooth interpolation) harder to implement.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Standard: Use InstancedMesh for identical objects (like Gems). This allows rendering thousands of items with a single draw call.</li> <li>Current: Each Gem is a separate <code>Mesh</code> object. While Three.js handles frustum culling, the CPU overhead of updating thousands of individual scene graph nodes every frame limits the maximum gem density.</li> </ul> </li> </ol>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#opportunities-for-improvement","title":"Opportunities for Improvement","text":""},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#1-asset-pipeline-integration","title":"1. Asset Pipeline Integration","text":"<p>Moving to a GLTF loader workflow would immediately improve visual fidelity.</p> <ul> <li>Action: Create a <code>AssetManager</code> class to load <code>.glb</code> files.</li> <li>Benefit: \"Real\" modeled plows with proper curves, metallic textures, and baked ambient occlusion.</li> </ul>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#2-instanced-rendering-for-gems","title":"2. Instanced Rendering for Gems","text":"<p>The \"Gem Fields\" concept requires high object counts.</p> <ul> <li>Action: Replace individual <code>IcosahedronGeometry</code> meshes with a single <code>THREE.InstancedMesh</code> managed by a specialized <code>GemRenderer</code> system.</li> <li>Benefit: Could easily support 10,000+ gems at 60fps, allowing for massive \"ocean of gems\" gameplay.</li> </ul>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#3-decoupled-rendering-state","title":"3. Decoupled Rendering State","text":"<p>Currently, visuals snap to physics state.</p> <ul> <li>Action: Implement a state interpolation buffer. Render at screen refresh rate (e.g., 144Hz) while physics runs at fixed steps (60Hz), interpolating positions <code>(prev * (1-alpha) + curr * alpha)</code>.</li> <li>Benefit: Eliminates micro-stutter and provides buttery smooth motion, even if physics frames drop.</li> </ul>"},{"location":"knowledge/legacy/GRAPHICS_DESIGN/#4-shader-effects","title":"4. Shader Effects","text":"<ul> <li>Action: Replace standard materials with custom ShaderMaterials for effects like \"Glow\" on high-value gems, \"Heat distortion\" behind the engine, or dynamic tracks that fade using a fragment shader time uniform instead of transparency updates.</li> </ul>"},{"location":"knowledge/legacy/SCAD_VS_BLENDER/","title":"Asset Pipeline: OpenSCAD vs. Blender","text":"<p>We originally explored two different pipelines for generating 3D game assets. We have decided to standardize on the Blender pipeline. This document summarizes the differences, benefits, and reasons for this decision.</p>"},{"location":"knowledge/legacy/SCAD_VS_BLENDER/#1-the-openscad-pipeline-programmers-cad","title":"1. The OpenSCAD Pipeline (\"Programmer's CAD\")","text":"<p>Approach:</p> <ul> <li>Define geometry using Constructive Solid Geometry (CSG) in <code>.scad</code> files.</li> <li>Compile to STL -&gt; OBJ -&gt; GLTF using a chain of tools (<code>openscad</code>, <code>obj2gltf</code>).</li> <li>Procedural textures generated at runtime in the client.</li> </ul> <p>Code Snippet (<code>bulldozer_body.scad</code>):</p> <pre><code>// Parametric definition\nbody_width = 12;\nbody_length = 16;\nbody_height = 5;\n\n// CSG Operations\ntranslate([-body_width/2, -body_length/2, 4/2])\n    cube([body_width, body_length, body_height]);\n</code></pre> <p>Pros:</p> <ul> <li>Parametric: Easy to adjust dimensions via variables.</li> <li>Git-Friendly: Source files are pure text.</li> <li>Precise: Exact mathematical alignment.</li> </ul> <p>Cons:</p> <ul> <li>Limited Export: OpenSCAD exports raw geometry (STL) without UVs, Materials, or scene hierarchy.</li> <li>Rendering Issues: The generated meshes often have bad normals or topology for game engines.</li> <li>No Animations: Cannot export armatures, keyframes, or separate parts easily without splitting into many files.</li> <li>Material Complexity: Requires custom \"Triplanar Mapping\" shaders in the client because the model lacks UV coordinates.</li> </ul>"},{"location":"knowledge/legacy/SCAD_VS_BLENDER/#2-the-blender-pipeline-game-ready-assets","title":"2. The Blender Pipeline (\"Game-Ready Assets\")","text":"<p>Approach:</p> <ul> <li>Use Python scripting inside Blender (<code>bpy</code>) to generate geometry programmatically.</li> <li>Export directly to <code>.glb</code> (GLTF binary) which supports hierarchy, materials, and animations.</li> <li>Use standard Three.js loaders in the client.</li> </ul> <p>Code Snippet (<code>bulldozer.py</code>):</p> <pre><code>import bpy\n\n# Create Mesh\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 1.0))\nbody = bpy.context.object\nbody.name = \"Bulldozer_Body\"\nbody.scale = (2.5, 4.0, 1.5)\n\n# Assign Material\nmat = bpy.data.materials.new(name=\"YellowPaint\")\nbody.data.materials.append(mat)\n\n# Export\nbpy.ops.export_scene.gltf(filepath=\"bulldozer.glb\", export_format='GLB')\n</code></pre> <p>Pros:</p> <ul> <li>Rich Assets: Exports a complete scene with node hierarchy, proper names, and material slots.</li> <li>UV Unwrapping: Can automatically project UVs (<code>bpy.ops.uv.smart_project</code>), allowing standard textures.</li> <li>Animation Support: Capable of baking animations and skeletal rigs.</li> <li>Debugging: The generated file can be opened in Blender GUI for visual inspection.</li> <li>Standard Rendering: Works with standard <code>MeshStandardMaterial</code> without shader hacks.</li> </ul> <p>Cons:</p> <ul> <li>Dependency: Requires Blender to be installed on the build machine.</li> <li>Complexity: The Blender Python API is more complex than SCAD.</li> </ul>"},{"location":"knowledge/legacy/SCAD_VS_BLENDER/#conclusion-why-blender","title":"Conclusion: Why Blender?","text":"<p>We chose the Blender pipeline because it produces Game-Ready Assets. The OpenSCAD pipeline required too much runtime \"patching\" (custom shaders for triplanar mapping, manual material assignment, lack of object hierarchy). The Blender pipeline gives us a standard GLTF file that \"just works\" in Three.js, while still maintaining the benefits of procedural generation via Python scripts.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/","title":"Common Errors &amp; Troubleshooting","text":""},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#asset-viewer","title":"Asset Viewer","text":""},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#failed-to-load-resource-script-unknown-source","title":"<code>Failed to load resource: &lt;SCRIPT&gt; unknown source</code>","text":"<p>Symptoms</p> <ul> <li>The asset viewer loads the UI but the 3D scene is empty.</li> <li>The console (or on-screen log) shows \"Failed to load resource\" pointing to the main module script.</li> <li>\"Three.js imported successfully\" is NOT logged.</li> </ul> <p>Cause: This error occurs when the browser cannot resolve one of the JavaScript modules imported by the viewer. Common reasons include:</p> <ol> <li>Incorrect Server Root: The web server was started from the <code>verification/</code> directory instead of the repository root. This makes <code>../js/</code> and <code>../node_modules/</code> inaccessible (404).</li> <li>Missing Dependencies: <code>npm install</code> has not been run, so <code>node_modules</code> is missing or incomplete.</li> <li>Deployment Path Issues: In a deployed environment (e.g., GitHub Pages), the relative paths to <code>js/</code> or <code>node_modules/</code> might be incorrect if the build script didn't rewrite them properly.</li> </ol> <p>Solution</p> <p>Local Development: Use the Taskfile commands to start the viewer from the correct root:</p> <pre><code>task damp:viewer\n</code></pre> <p>Deployment: Check the <code>pr-preview.yml</code> workflow to ensure it copies source files to the <code>dist/</code> folder and rewrites paths (<code>sed</code>) in <code>index.html</code>.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#failed-to-load-resource-bulldozer_componentsglb-404","title":"<code>Failed to load resource: ... bulldozer_components.glb</code> (404)","text":"<p>Cause: The 3D assets have not been built locally.</p> <p>Solution</p> <p>Run the asset build task:</p> <pre><code>task build:assets\n</code></pre> <p>Note: The asset viewer handles this gracefully by logging a warning, but the model will not appear.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#graphics-glitches","title":"Graphics Glitches","text":""},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#fan-like-vertical-tracks","title":"\"Fan-like\" Vertical Tracks","text":"<p>Cause: The track link mesh orientation in the GLB does not match the animation logic (Three.js <code>lookAt</code> expects Z-forward).</p> <p>Solution</p> <p>Use the \"Track Adj\" controls in the Asset Viewer to set Z-Rotation to 270.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#flickering-vanishing-tracks","title":"Flickering / Vanishing Tracks","text":"<p>Cause: Gimbal lock when the track tangent aligns with the World Y-axis.</p> <p>Solution</p> <p>Ensure the \"Up\" vector in the Asset Viewer is set to X (Axle).</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/","title":"Graphics Troubleshooting: The \"Striped Shadow\" Artifact","text":""},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-issue","title":"The Issue","text":"<p>In 3D rendering, you may observe weird, striped shadow patterns across surfaces that look like texture glitches or blinds. This is often described as \"Shadow Acne\" or \"Self-Shadowing Artifacts.\"</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-cause","title":"The Cause","text":"<p>This is a fundamental limitation of Shadow Mapping.</p> <ol> <li>Depth Map Resolution: The light source renders the scene depth to a texture (the Shadow Map). This texture has limited resolution (e.g., 1024x1024 pixels).</li> <li>Quantization: When checking if a pixel on the screen is in shadow, the engine compares the pixel's depth to the value stored in the shadow map.</li> <li>The Glitch: Due to limited precision (quantization) and the angle of the light, a flat surface might calculate its depth as slightly behind the value in the shadow map for some pixels and in front for others. This causes the surface to cast a shadow on itself in a striped pattern.</li> </ol>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-fix","title":"The Fix","text":"<p>We need to tune the Shadow Bias.</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#1-bias-offset","title":"1. Bias (Offset)","text":"<p>This pushes the shadow slightly deeper/away from the light.</p> <ul> <li>Too Low: Acne remains.</li> <li>Too High: \"Peter Panning\" (shadows detach from the object).</li> </ul>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#2-normal-bias","title":"2. Normal Bias","text":"<p>This pushes the shadow lookup coordinate along the surface normal. This is very effective for curved or low-poly geometry (like our programmer art).</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#implementation-in-threejs","title":"Implementation in Three.js","text":"<pre><code>const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\ndirLight.castShadow = true;\n\n// The Fix:\ndirLight.shadow.bias = -0.0005;      // Slight offset to remove acne\ndirLight.shadow.normalBias = 0.05;   // Pushes shadow based on surface angle\n</code></pre> <p>We have applied this fix to <code>asset_viewer.html</code>.</p>"},{"location":"living/architecture/BLENDER_PIPELINE/","title":"Asset Generation: The \"Game Ready\" Pipeline (Blender + Python)","text":"<p>While OpenSCAD is excellent for \"Programmer CAD,\" it struggles with game-specific needs like UV Mapping and Topology. We have introduced a second pipeline option: Blender Python Scripting.</p> <p>This allows you to generate assets using Python code (keeping the \"Programmer\" workflow) while leveraging Blender's industry-standard tools for UV unwrapping and GLTF export.</p>"},{"location":"living/architecture/BLENDER_PIPELINE/#architecture","title":"Architecture","text":"<ol> <li>Source: Python scripts (<code>.py</code>) located in <code>pipeline/blender/</code>.</li> <li>Engine: Blender (headless mode).</li> <li>Compilation: <code>task build:assets</code> runs Blender to execute the script and export <code>.glb</code>.</li> <li>Result: Game-ready assets with UVs, Materials, and Explicit IDs.</li> </ol>"},{"location":"living/architecture/BLENDER_PIPELINE/#mapping-configuration-assetsconfigs","title":"Mapping Configuration (<code>assets/configs/</code>)","text":"<p>For each GLB asset, you must typically create a corresponding mapping configuration file (e.g., <code>my_asset_mapping.json</code>) in <code>assets/configs/</code>. This file acts as the \"Contract\" between the raw geometry and the game engine's renderer.</p> <p>It maps the <code>damp_id</code> (defined in your Blender script) to specific material presets or textures.</p> <p>Example <code>plow_mapping.json</code>: <pre><code>{\n  \"assetId\": \"plow.glb\",\n  \"components\": {\n    \"plow_segment\": {\n      \"preset\": \"YellowMetallic\",\n      \"roughness\": 0.2,\n      \"metalness\": 0.7\n    }\n  }\n}\n</code></pre></p>"},{"location":"living/architecture/BLENDER_PIPELINE/#how-to-use","title":"How to use","text":"<ol> <li>Create a python script in <code>pipeline/blender/my_asset.py</code>.</li> <li>Use the <code>bpy</code> library to generate geometry.</li> <li>Run <code>task build:assets</code>.</li> </ol> <p>Tip: Headless Mode</p> <p>The pipeline runs Blender in background mode (<code>-b</code>), so no UI window will open. If you need to debug geometry, you can open the generated GLB in a standard GLTF viewer or open Blender manually to run the script.</p>"},{"location":"living/architecture/BLENDER_PIPELINE/#example-blender-script","title":"Example Blender Script","text":"<pre><code>import bpy\n\n# Clear existing\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create Cube\nbpy.ops.mesh.primitive_cube_add(size=2)\nobj = bpy.context.object\n\n# Tag for DAMP\nobj[\"damp_id\"] = \"test_cube\"\n\n# Auto UV Unwrap\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.uv.smart_project()\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Export logic is handled by the wrapper script,\n# but locally you might verify with:\n# bpy.ops.export_scene.gltf(filepath=\"my_asset.glb\")\n</code></pre>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/","title":"DAMP Architecture &amp; Rationale","text":"<p>Distributed Asset &amp; Material Pipeline (DAMP)</p> <p>This document outlines the architectural decisions and \"Explicit Contract\" model that governs the asset pipeline for the Gem Miner project.</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#1-core-philosophy-explicit-implicit","title":"1. Core Philosophy: \"Explicit &gt; Implicit\"","text":"<p>The primary design principle is Explicit Contracts. We avoid \"Implicit Logic\" (guessing mesh names like <code>Cube001</code>, assuming default alignments, or relying on runtime discovery).</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#the-contract-model","title":"The Contract Model","text":"<ul> <li>Blender (Provider): Explicitly tags Materials and Objects with a permanent <code>damp_id</code> custom property.</li> <li>GLB (Artifact): Carries these IDs in the standard <code>extras</code> or <code>userData</code> fields.</li> <li>Renderer (Consumer): Strictly enforces the contract. It looks for <code>damp_id</code> and maps functionality to it.</li> </ul> <p>Implicit Logic (Bad)</p> <p>Searching for mesh names like <code>Cube001</code> or <code>Cylinder</code> is fragile because Blender often renames things automatically.</p> <p>Explicit Contract (Good)</p> <p>The renderer only cares about <code>damp_id=\"chassis\"</code>. The geometry name can be anything.</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#2-the-four-pillars-structure","title":"2. The \"Four Pillars\" Structure","text":"<p>To maintain separation of concerns, the codebase is divided into four distinct domains:</p> <ol> <li><code>src/</code> (Game Source): The runtime game logic. It consumes assets but does not generate them.</li> <li><code>pipeline/</code> (Asset Factory): The \"Source of Truth\" for assets. Contains Blender Python scripts and procedural texture generators.</li> <li><code>tools/</code> (DX Tools): Developer tools like the Asset Viewer (<code>tools/viewer</code>) that verify assets in isolation.</li> <li><code>assets/</code> (Output/Artifacts): The compiled <code>.glb</code> and configuration files.</li> </ol>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#3-pipeline-flow","title":"3. Pipeline Flow","text":"<p>The asset generation flow is automated via <code>task build:assets</code>:</p> <pre><code>graph LR\n    A[Blender Script] --&gt;|Generate &amp; Tag| B(GLB Artifact)\n    B --&gt;|Load| C[Asset Viewer]\n    B --&gt;|Load| D[Game Engine]\n</code></pre> <ol> <li>Generation: <code>pipeline/blender/bulldozer.py</code> generates geometry, parents objects, injects <code>damp_id</code>, and bakes transforms.</li> <li>Compilation: Exports a <code>.glb</code> and updates <code>catalog.json</code>.</li> <li>Consumption: <code>BulldozerRenderer</code> loads the GLB and applies materials based on IDs.</li> </ol>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#4-key-architectural-decisions-rationale","title":"4. Key Architectural Decisions (Rationale)","text":""},{"location":"living/architecture/DAMP_MAINTAINABILITY/#a-parenting-vs-joining","title":"A. Parenting vs. Joining","text":"<p>Decision</p> <p>Use Object Parenting, not <code>bpy.ops.object.join()</code>.</p> <p>Rationale: Joining meshes destroys object-level metadata and forces Three.js to split primitives at runtime, causing race conditions and losing the <code>damp_id</code> on sub-parts. Parenting preserves the logical hierarchy and metadata.</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#b-material-level-tagging","title":"B. Material-Level Tagging","text":"<p>Decision</p> <p>Tag Materials (<code>mat[\"damp_id\"]</code>) in addition to Objects.</p> <p>Rationale: Custom properties on Materials are more resilient. Even if geometry is merged or instanced, Three.js preserves material slots, allowing the renderer to reliably identify \"Glass\" vs \"Steel\" parts.</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#c-baked-transforms","title":"C. Baked Transforms","text":"<p>Decision</p> <p>Bake scale and rotation in Blender; avoid runtime adjustments.</p> <p>Rationale: Early iterations attempted to fix rotation (Y-up vs Z-up) in JavaScript. This led to \"Tiny Bodies and Giant Tracks\" bugs. Baking the transforms ensures that <code>(1,1,1)</code> in the game engine matches the intended visual size.</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#d-centralized-utilities","title":"D. Centralized Utilities","text":"<p>Decision</p> <p>Move cache-busting (<code>cb()</code>) and common logic to <code>src/utils/graphics-utils.js</code>.</p> <p>Rationale: Previously, the Viewer and the Game had separate utility implementations, leading to \"ghost bugs\" where one saw cached assets and the other saw new ones. A shared utility ensures consistency.</p>"},{"location":"living/architecture/DAMP_MAINTAINABILITY/#5-component-lifecycle","title":"5. Component Lifecycle","text":"<p>The standard lifecycle for an asset-based entity (like the Bulldozer) is:</p> <ol> <li><code>init()</code>: Physics body created (invisible).</li> <li><code>load()</code>: <code>BulldozerRenderer</code> fetches the GLB.</li> <li><code>setup()</code>:<ul> <li>Traverses GLB.</li> <li>Identifies Tracks (extracts Curves).</li> <li>Identifies Chassis/Parts (applies Materials).</li> </ul> </li> <li><code>update()</code>: Syncs the root Mesh position/rotation to the Physics Body.</li> </ol> <p>Last Updated: 2025-05-19</p>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/","title":"DAMP Pipeline Review &amp; Design Commentary","text":""},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#1-architectural-overview","title":"1. Architectural Overview","text":"<p>The Distributed Asset &amp; Material Pipeline (DAMP) successfully bridges the gap between Programmatic CAD (Blender/Python) and Real-time Web Rendering (Three.js). It follows a \"Source-of-Truth\" model where geometry is generated on-demand, and a JSON configuration layer decouples the visual styling from the raw mesh data.</p>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#the-flow","title":"The Flow:","text":"<ol> <li>Geometry (<code>bulldozer.py</code>): Defines the \"bones\" and \"shell\" of the entity using Blender's Python API.</li> <li>Texture Gen (<code>bulldozer.py</code>): Captures procedural details into static PNGs to avoid expensive real-time procedural overhead.</li> <li>Orchestration (<code>task</code>): Compiles raw assets into a <code>catalog.json</code> for the web runtime and ensures consistent directory structures.</li> <li>Configuration (<code>assets/configs/*.json</code>): A manually created \"Contract\" file that defines the \"skin\"\u2014mapping textures and material physics (roughness, metalness, transparency) to specific meshes via <code>damp_id</code>.</li> <li>Runtime (<code>bulldozer_render.js</code>): Interprets the GLB + Config to assemble the final high-fidelity entity in the game engine.</li> </ol>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#2-design-commentary","title":"2. Design Commentary","text":""},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#strengths","title":"Strengths","text":"<ul> <li>WYSIWYG Development: The Asset Director (Viewer) allows for real-time material tuning that can be exported directly to the game's config files.</li> <li>Decoupled Logic: Geometry changes in Blender don't require code changes in the game engine, provided the naming conventions remain stable.</li> <li>Performance Optimization: By baking procedural textures into PNGs during the build step, client-side GPU load is kept low while maintaining high visual detail.</li> <li>Material Presets: The \"Preset\" system (e.g., Glass, Track) allows for high-fidelity Three.js materials to be defined in code while still being configurable via JSON.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#current-challenges-the-magic-mapping","title":"Current Challenges (The \"Magic\" Mapping)","text":"<p>The most brittle part of the current design is the Generic Mesh Mapping.</p> <ul> <li>Issue: When Blender joins meshes, it creates names like <code>Cube001</code>, <code>Cube001_1</code>. The renderer has to \"guess\" that <code>Cube001_1</code> is a wheel based on material or generic string matches.</li> <li>Risk: Changes in Blender's joining order could swap these names, breaking the texture mapping in the game.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#3-technical-review-cleanup","title":"3. Technical Review &amp; Cleanup","text":""},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#pipelineblenderbulldozerpy","title":"<code>pipeline/blender/bulldozer.py</code>","text":"<ul> <li>Status: Updated to use Parenting.</li> <li>Implementation: The script now parents components (Wheels, Cabin) to the Body and uses <code>tag_contract</code> to assign <code>damp_id</code> custom properties. This allows the GLB to maintain a hierarchy and precise identification.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#jsentitiesbulldozer_renderjs","title":"<code>js/entities/bulldozer_render.js</code>","text":"<ul> <li>Review: The <code>applyMaterial</code> logic currently performs heavy string matching to \"fix\" generic Blender export names.</li> <li>Cleanup: Standardize the <code>cb()</code> (cache-busting) utility across the project to reduce code duplication.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#viewersrcmainjs","title":"<code>viewer/src/main.js</code>","text":"<ul> <li>Review: The UI \"Discovery\" logic is clever but can be prone to race conditions with the renderer's initial load.</li> <li>Cleanup: Centralize component discovery within the <code>BulldozerRenderer</code> itself.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#4-roadmap-status","title":"4. Roadmap &amp; Status","text":""},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#phase-1-explicit-component-tagging-completed","title":"Phase 1: Explicit Component Tagging (Completed)","text":"<p>We have implemented Blender Custom Properties to identify meshes.</p> <ul> <li>Blender Python: <code>obj[\"damp_id\"] = \"chassis\"</code></li> <li>Three.js Runtime: The GLTF loader reads these from <code>mesh.userData.damp_id</code>.</li> <li>Result: Reliable mapping independent of Blender's internal naming or joining order.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#phase-2-unified-material-schema","title":"Phase 2: Unified Material Schema","text":"<p>Formalize the mapping JSON into a generic schema that supports:</p> <ul> <li><code>emissive</code> properties for glowing lights.</li> <li><code>normalMap</code> support for surface bump details.</li> <li><code>envMapIntensity</code> for more realistic glass reflections.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#phase-3-build-pipeline-hardening","title":"Phase 3: Build Pipeline Hardening","text":"<ul> <li>Schema Validation: Validate JSON configs against a schema during the build step to catch typos before runtime.</li> <li>Automated Thumbnails: Integrate a headless browser step to generate preview thumbnails for the <code>catalog.json</code>.</li> </ul>"},{"location":"living/architecture/DAMP_PIPELINE_REVIEW/#5-immediate-cleanup-checklist","title":"5. Immediate Cleanup Checklist","text":"<ul> <li> Consolidate Utilities: Move <code>cb()</code> cache-busting to a shared utility file.</li> <li> Blender Refactor: Update <code>bulldozer.py</code> to use parenting instead of joining for critical components.</li> <li> Remove Legacy Artifacts: Delete <code>existing_pipeline_files.txt</code> and unused <code>/verification</code> scripts.</li> <li> Standardize Interfaces: Ensure all renderers use the same <code>setPose(position, angle)</code> interface.</li> </ul> <p>Review Date: Thursday 18 December 2025</p>"},{"location":"living/guide/PROJECT_STRUCTURE/","title":"Project Structure","text":"<p>Last Updated: 2025-05-19</p> <p>The project follows a \"Modern Standard\" structure to separate source code, build pipelines, and developer tools.</p>"},{"location":"living/guide/PROJECT_STRUCTURE/#directory-layout","title":"Directory Layout","text":"<ul> <li><code>src/</code>: Main Game Source Code.<ul> <li> <code>core/</code>: Engine logic (Game loop, Graphics, Physics, UI).</li> <li> <code>entities/</code>: Game Objects (Bulldozer, Gems, Map).</li> <li> <code>utils/</code>: Shared utilities (Math, Graphics).</li> </ul> </li> <li><code>pipeline/</code>: The Asset Factory (\"Source of Truth\").<ul> <li> <code>blender/</code>: Python scripts for geometry generation.</li> <li> <code>textures/</code>: Python scripts for procedural texture generation.</li> <li> <code>scripts/</code>: Node.js build and verification scripts.</li> </ul> </li> <li><code>tools/</code>: Developer Tools.<ul> <li> <code>viewer/</code>: The DAMP Asset Director (Web App).</li> <li> <code>physics-playground/</code>: Isolated physics testing environment.</li> </ul> </li> <li><code>assets/</code>: Source configuration for assets.<ul> <li> <code>configs/</code>: JSON configuration files for the pipeline.</li> </ul> </li> <li><code>docs/</code>: Project Documentation.</li> <li><code>dist/</code>: (Generated) Build artifacts, including compiled assets and the playable game.</li> </ul>"},{"location":"living/guide/PROJECT_STRUCTURE/#key-workflows","title":"Key Workflows","text":""},{"location":"living/guide/PROJECT_STRUCTURE/#setup","title":"Setup","text":"<p>Ensure you have <code>uv</code> and <code>go-task</code> installed (handled by <code>.julesrc</code> in dev container).</p>"},{"location":"living/guide/PROJECT_STRUCTURE/#commands","title":"Commands","text":"Run Build Command Description <code>task dev</code> Starts the main game server locally. <code>task damp:viewer</code> Starts the Asset Viewer tool. Command Description <code>task build:assets</code> Runs the full Blender pipeline to generate GLBs and textures. <code>task build:dist</code> Creates a production build in <code>dist/</code>. <code>task docs:build</code> Builds this documentation site."},{"location":"living/guide/game_design_principles/","title":"Game Design Principles","text":"<p>Philosophy</p> <p>This document captures the core design philosophies for this project. When making decisions, refer to these principles to ensure the game \"feels\" right.</p>"},{"location":"living/guide/game_design_principles/#1-the-juice-game-feel","title":"1. The \"Juice\" (Game Feel)","text":"<p>\"Juice\" is the tactile feedback that makes interaction satisfying. *   Everything Reacts: When an object is touched, collected, or bought, it must react. (Particles, floating text, sound, scale bounce). *   Instant Feedback: Never delay the visual result of an action. If a gem is collected, it disappears this frame, even if the logic takes longer. *   Exaggeration: Realism is secondary to clarity. A 10% upgrade should look like a 10% upgrade, but a Level 10 bulldozer should look absurdly powerful compared to Level 1.</p>"},{"location":"living/guide/game_design_principles/#2-progression-pacing","title":"2. Progression &amp; Pacing","text":"<ul> <li>The Power Fantasy: The player starts weak and slow. The goal is to make them feel unstoppable by the end.</li> <li>Micro-Goals: The player should always have a goal reachable within 1-2 minutes (e.g., \"Buy next Engine level\").</li> <li>Macro-Goals: The player needs a horizon goal (e.g., \"Unlock the Red Zone\").</li> <li>Friction vs. Flow:<ul> <li>Friction (Slow movement, walls) makes the Flow (Speed upgrades, breaking through) satisfying.</li> <li>Do not remove all friction too early.</li> </ul> </li> </ul>"},{"location":"living/guide/game_design_principles/#3-clarity-readability","title":"3. Clarity &amp; Readability","text":"<ul> <li>Form Follows Function: A \"Collector\" should look like it collects things (funnels, belts). A \"Shop\" should look like a place of transaction.</li> <li>Visual Hierarchy: The most important elements (The Player, The Gems) must contrast with the background.</li> <li>Numbers: Keep numbers readable. \"1.5k\" is better than \"1500\" in tight UI, but precise numbers feel more \"RPG-like\" in stats panels.</li> </ul>"},{"location":"living/guide/game_design_principles/#4-engineering-for-design","title":"4. Engineering for Design","text":"<ul> <li>Exposed Knobs: Design systems with \"Knobs\" (Constants, Configs) that can be tweaked without rewriting logic.</li> <li>Iterative Balance: Balance is never done. Build tools (like the Asset Viewer or Debug Consoles) that help us \"feel\" the values.</li> <li>Separation of Logic and Visuals: The physics simulation (Matter.js) is the \"Truth\", but the Visuals (Three.js) are the \"Experience\". It's okay to cheat visuals (e.g., floating coins) to make it look good.</li> </ul>"},{"location":"living/guide/game_design_principles/#5-next-steps-for-better-design","title":"5. Next Steps for \"Better\" Design","text":"<ul> <li>Sound: Currently missing. Sound is 50% of the \"Juice\".</li> <li>Save/Load: Progression is meaningless if lost on refresh.</li> <li>Victory Lap: After winning, give the player a \"Toy\" (e.g., infinite speed, sandbox mode) to enjoy their power.</li> </ul>"},{"location":"living/guide/progression_analysis/","title":"Progression Analysis (Current State)","text":"<p>Metadata</p> <ul> <li>Date: 2026-01-13</li> <li>Version: 1.8 (Deep Permutation Analysis)</li> <li>Scope: Current values for costs, entity stats, and economy.</li> </ul> <p>Context</p> <p>This document outlines the current mathematical models governing the game's progression, including upgrade costs, entity scaling, and economic availability.</p>"},{"location":"living/guide/progression_analysis/#1-economy-gems","title":"1. Economy (Gems)","text":"<p>The game world is divided into three zones. Gems are the sole source of currency.</p> Zone Gems Value Range Avg Value Zone Total (Approx) Unlock Condition 1 400 8 - 12 10 $4,000 Start 2 400 25 - 40 32.5 $13,000 50% of Zone 1 Collected 3 400 60 - 100 80 $32,000 50% of Zone 2 Collected Total 1200 ~$49,000"},{"location":"living/guide/progression_analysis/#2-upgrade-costs","title":"2. Upgrade Costs","text":"<p>All upgrades follow a simple exponential growth curve: <code>NewCost = floor(OldCost * 1.5)</code>.</p> Upgrade Base Cost Growth Cost @ Lvl 5 Cost @ Lvl 10 Engine 100 x1.5 506 3,844 Plow 100 x1.5 506 3,844 Collector 150 x1.5 759 5,766"},{"location":"living/guide/progression_analysis/#3-entity-scaling-verification","title":"3. Entity Scaling Verification","text":""},{"location":"living/guide/progression_analysis/#performance-curves","title":"Performance Curves","text":"<p>The following charts illustrate Top Speed (px/frame) and Acceleration (Distance traveled in 5s) across five progression scenarios:</p> <ol> <li>A: Engine Lag (Engine=1, Plow=1): The \"Control\" group. The player upgrades only the Collector. Since the Collector is a static sensor body, it does not affect the bulldozer's mass or physics. This line is flat.</li> <li>B: Engine Focus (Plow=1): The \"Racer\" build. The player upgrades only the Engine, keeping the Plow at Level 1. This minimizes mass gain while maximizing power, resulting in the highest possible speeds.</li> <li>C: Balanced (All Levels Equal): The \"Standard\" progression. The player upgrades Engine, Plow, and Collector roughly equally.</li> <li>D: Collector Lead +1 (Engine=L, Plow=L, Coll=L+1): Verifies that having the Collector one level ahead of the drivetrain does not negatively impact physics. This line overlaps \"Balanced\".</li> <li>E: Collector Lead +2 (Engine=L, Plow=L, Coll=L+2): Verifies that having the Collector two levels ahead does not impact physics. This line overlaps \"Balanced\".</li> </ol> <p></p>"},{"location":"living/guide/progression_analysis/#methodology","title":"Methodology","text":"<p>These graphs were generated empirically by <code>verification/measure_scaling.py</code>. The script uses a headless version of the game's physics engine (<code>verification/scaling_harness.html</code>) to simulate the bulldozer's movement over 300 frames (5 seconds) for each permutation of levels 1-20.</p> <ul> <li>Speed: Peak velocity magnitude observed during the run.</li> <li>Acceleration: Total distance traveled from a standstill in 5 seconds.</li> </ul>"},{"location":"living/guide/progression_analysis/#wingtip-offsets-plow-width-scaling","title":"Wingtip Offsets (Plow Width Scaling)","text":"<p>As the plow upgrades (Level 3+), \"wings\" are added. The table below shows the offset of the wingtip relative to the main plow edge.</p> Level Wingtip Offset (units) 1-2 0.00 3 28.83 5 36.79 10 56.70 20 96.53 <p>Observations (Post-Fix):</p> <ul> <li>Baseline Improvement: Starting speed is now ~5.0 px/f (vs ~2.9), making the base bulldozer feel more responsive.</li> <li>Progression Gap: The Level 3 \"Dip\" has been significantly mitigated.</li> <li>Late Game: Speed scales aggressively (up to ~56 px/f at Lvl 20), delivering the requested \"Power Fantasy\".</li> <li>Collector Impact: Upgrading the collector (Scenarios D &amp; E) has zero impact on physics, as confirmed by the curves overlapping the Standard progression.</li> </ul>"},{"location":"living/guide/progression_analysis/#implemented-logic","title":"Implemented Logic","text":"<p><code>Force = (0.012 * 1.35^Level) + (Mass * 0.001)</code></p> <ul> <li>Base Power: Increased exponent from 1.25 to 1.35.</li> <li>Mass Compensation: Added <code>Mass * 0.001</code> to force calculation.</li> </ul>"},{"location":"planning/2024-05-23_plow_integration/","title":"Plow Asset Integration &amp; Upgrades","text":"<p> Metadata</p> <ul> <li>Status: In Progress</li> <li>Date: 2024-05-23</li> <li>Author: Jules</li> <li>Tags: Asset, Plow, Upgrades, Graphics, DAMP</li> </ul> <p> Context</p> <p>A new plow asset (<code>plow.glb</code>) has been designed and merged (source files). This task focuses on integrating this asset into the game, enabling dynamic width upgrades (segment instancing), implementing wing scaling based on upgrades, and adding logic for toggleable teeth.</p> <p>Reference: Plow Asset Design</p> <p> Plan</p> <ol> <li> <p>Asset Loading</p> <ul> <li>Update <code>BulldozerRenderer</code> to load <code>plow.glb</code> in addition to <code>bulldozer_components.glb</code>.</li> <li>Implement <code>loadPlow(url, configUrl)</code> to merge plow configuration into the main renderer config.</li> <li>Ensure <code>Plow_Segment</code>, <code>Plow_Tooth</code>, and <code>Plow_Wing</code> components are extracted from <code>plow.glb</code>.</li> </ul> </li> <li> <p>Plow Upgrades (Width)</p> <ul> <li>Map <code>state.plowLevel</code> to <code>segmentCount</code>.</li> <li>Formula: <code>3 + (state.plowLevel - 1)</code> segments (Level 1 = 3 segments).</li> <li>Sync this value via <code>BulldozerRenderer.setPlowWidth()</code>.</li> </ul> </li> <li> <p>Wing Scaling</p> <ul> <li>Activation: Wings appear at Level 3 (<code>state.plowLevel &gt;= 3</code>).</li> <li>Scaling Logic: <code>1.0 + (state.plowLevel - 3) * 0.1</code> (Linear growth starting at Lvl 3).</li> <li>Update <code>BulldozerRenderer.updatePlow</code> to apply scaling to wing meshes (<code>wingL</code>, <code>wingR</code>).</li> <li>Expose <code>setPlowWings(enabled, scale)</code>.</li> </ul> </li> <li> <p>Teeth Logic</p> <ul> <li>Implement conditional visibility for teeth.</li> <li>User requirement: \"I don't want the teeth to always be enabled.\"</li> <li>Logic: Controlled by <code>state.plowTeethEnabled</code> flag.</li> <li>Expose <code>setPlowTeeth(enabled)</code>.</li> </ul> </li> <li> <p>Integration</p> <ul> <li>Update <code>src/core/game.js</code> to trigger <code>loadPlow</code> after main assets are loaded.</li> <li>Update <code>src/core/graphics.js</code> inside <code>updateGraphics</code> to sync visual state with game state every frame.</li> </ul> </li> </ol> <p> Execution Log</p> <ul> <li> Create tracking document.</li> <li> Update <code>BulldozerRenderer</code> to support separate plow loading (<code>loadPlow</code>).</li> <li> Implement wing scaling logic in renderer (<code>setPlowWings</code> with scale param).</li> <li> Hook up game state to renderer in <code>graphics.js</code> (sync level to width/wings).</li> <li> Verify code logic via Playwright verification script.</li> </ul>"},{"location":"planning/plow_asset_design/","title":"Plow asset design","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2024-05-23</li> <li>Author: Jules</li> <li>Tags: Asset, Design, Plow, DAMP</li> </ul> <p> Context</p> <p>The bulldozer requires a modular plow asset that can scale horizontally as the player upgrades their plow level. The design needs to support a core repeatable segment, optional teeth for digging, and \"wings\" (side caps) to funnel collected gems.</p> <p> Design Specification</p> <p> Execution Log</p> <ul> <li> Create basic <code>Plow_Segment</code> geometry in Blender API.</li> <li> Integrate into DAMP pipeline (<code>plow.py</code>, <code>Taskfile.yml</code>).</li> <li> Implement <code>BulldozerRenderer</code> support for instanced segments.</li> <li> Add Viewer UI for segment count configuration.</li> <li> Refinement: Add <code>Plow_Tooth</code> with forward-down angle.</li> <li> Refinement: Add <code>Plow_Wing</code> with curved funnel shape.</li> <li> Refinement: Reduce wing curvature and fix normals (solid horn look).</li> <li> Refinement: Flip wing curvature to flare OUT (funnel).</li> <li> Verify final look in Viewer.</li> </ul> <p> Outcome</p> <p>The asset has been successfully generated (<code>assets/models/plow.glb</code>) containing:</p> <ul> <li><code>Plow_Segment</code>: Repeatable blade unit.</li> <li><code>Plow_Tooth</code>: Optional digging attachment.</li> <li><code>Plow_Wing_L</code> / <code>Plow_Wing_R</code>: Optional side funnels.</li> </ul> <p>Integration is now tracked in Plow Asset Integration.</p>"},{"location":"planning/plow_asset_design/#core-philosophy","title":"Core Philosophy","text":"<p>The plow is a tool of accumulation. It should look sturdy, industrial, and capable of pushing massive amounts of material.</p>"},{"location":"planning/plow_asset_design/#components","title":"Components","text":"<ol> <li> <p>Plow Segment (<code>Plow_Segment</code>)</p> <ul> <li>Role: The main blade body.</li> <li>Dimensions: 1.0 meter width (standard unit).</li> <li>Shape: Concave profile to \"catch\" material. Includes a \"Parky\" cutting edge at the bottom.</li> <li>Behavior: Instanced N times based on plow width upgrade.</li> </ul> </li> <li> <p>Plow Teeth (<code>Plow_Tooth</code>)</p> <ul> <li>Role: Aggressive digging implements.</li> <li>Shape: Angled wedge, pointing forward and down.</li> <li>Material: Dark, rough metal (contrasting with the yellow blade).</li> <li>Behavior: Optional upgrade. Instanced 1 per segment.</li> </ul> </li> <li> <p>Plow Wings (<code>Plow_Wing_L</code> / <code>Plow_Wing_R</code>)</p> <ul> <li>Role: Funneling. Increases effective capture area.</li> <li>Shape: Curved \"horn\" design. Extends forward and flares OUTWARD.</li> <li>Behavior: Optional upgrade. Attached to the outermost ends of the segment array.</li> </ul> </li> </ol>"},{"location":"planning/plow_asset_design/#visual-reference-procedural","title":"Visual Reference (Procedural)","text":"<ul> <li>Blade: Yellow/Industrial Paint (Roughness 0.2, Metalness 0.7).</li> <li>Teeth: Unpainted Steel/Iron (Roughness 0.9, Metalness 0.1, Dark Grey).</li> </ul>"},{"location":"planning/roadmap/","title":"Roadmap","text":""},{"location":"planning/roadmap/#active-work","title":"Active Work","text":"<ul> <li> Speed &amp; Acceleration Tuning: Tuning physics for better weight and smoother progression. (View Plan)</li> <li> Scaling Rebalance: Rebalancing game economy and progression. (View Plan)</li> <li> Scaling Analysis: Verify and analyze bulldozer stats across all levels. (Completed)</li> <li> Documentation Rewrite: Full audit and restructure of project documentation to reflect current state. (View Plan)</li> <li> UI &amp; Gameplay Polish: Replaced physical \"Money Mat\" with flying coin UI animation and fixed collector upgrade scaling. (View Plan)</li> <li> Plow Integration: Integrate new plow asset with dynamic width and wing scaling upgrades. (View Plan)</li> </ul>"},{"location":"planning/roadmap/#backlog","title":"Backlog","text":"<ul> <li> Asset Pipeline Optimization: Further refinements to the Blender -&gt; GLB pipeline.</li> <li> Gameplay Features: Additional upgrades and levels.</li> <li> Mobile Optimization: Improve touch controls and performance on mobile devices.</li> </ul>"},{"location":"planning/scaling_analysis/","title":"Scaling Analysis and Verification","text":"<p> Metadata</p> <ul> <li>Status: In Progress</li> <li>Date: 2024-05-23</li> <li>Author: Jules</li> <li>Task: <code>app-p1x</code></li> </ul> <p> Context</p> <p>Users have reported that the \"Power Fantasy\" element of the upgrades feels lacking. The visual and physical scaling of the bulldozer might not be matching the intended design curves. We need to verify the actual runtime values for Mass, Size, Force, and Top Speed across all levels (1-20).</p> <p> Plan</p> <ol> <li>Create a headless (visual-less) harness <code>verification/scaling_harness.html</code> that runs the actual game physics code.</li> <li>Mock the graphics subsystem to avoid WebGL dependencies during testing.</li> <li>Automate the collection of data using a Playwright script <code>verification/measure_scaling.py</code>.</li> <li>Update <code>docs/guide/progression_analysis.md</code> with the empirical data.</li> </ol> <p> Execution Log</p> <ul> <li> Create <code>verification/mocks/graphics.js</code></li> <li> Create <code>verification/scaling_harness.html</code></li> <li> Create <code>verification/measure_scaling.py</code></li> <li> Run analysis</li> <li> Update documentation</li> </ul>"},{"location":"planning/speed_and_acceleration_tuning/","title":"Task: Speed &amp; Acceleration Tuning","text":"<p> Metadata</p> <ul> <li>Status: In Progress</li> <li>Date: 2026-01-13</li> <li>Author: Jules</li> <li>Type: Rebalance</li> </ul> <p> Context</p> <p>The current movement physics are too aggressive. The bulldozer starts too fast at level 1, scales to uncontrollable speeds at high levels, and accelerates/stops almost instantly. We need to introduce more \"weight\" (inertia) and smooth out the progression curve. Update: The initial inertia fix (low friction) caused \"drift/slippery\" turning. We need to implement lateral friction to ensure snappy turns while keeping forward momentum.</p> <p> Plan</p> <ol> <li>Adjust Physics Parameters<ul> <li>Lower <code>frictionAir</code> in <code>src/entities/bulldozer.js</code> to increase coasting (time to stop).</li> <li>Refactor Force calculation in <code>src/core/input.js</code> to align with the new friction and desired speed curve.</li> <li>Reduce the exponent for power scaling to prevent late-game uncontrollability.</li> </ul> </li> <li>Fix Turning Drift<ul> <li>Implement \"Lateral Friction\" in <code>src/core/input.js</code> to dampen sideways velocity.</li> </ul> </li> <li>Verify Scaling<ul> <li>Use <code>verification/measure_scaling.py</code> to generate new progression curves.</li> <li>Ensure Level 1 speed is manageable (~3-4 px/f) and Level 20 is fast but not broken (~25-30 px/f).</li> </ul> </li> </ol> <p> Execution Log</p> <ul> <li> Archive Old Plan: Moved <code>task_scaling_rebalance.md</code> to archive.</li> <li> Physics Tuning: Adjusted <code>frictionAir</code> and Power formula.</li> <li> Verification: Generated new <code>progression_curves.png</code> and updated analysis doc.</li> </ul>"},{"location":"planning/task_agent_playtesting/","title":"Task: Implement Agent Playtesting Framework","text":"<p>This task involves building the necessary infrastructure to allow AI agents to perform automated, measurable playtests of the Gem Miner game.</p>"},{"location":"planning/task_agent_playtesting/#status-planning","title":"Status:  Planning","text":""},{"location":"planning/task_agent_playtesting/#required-infrastructure","title":"Required Infrastructure","text":""},{"location":"planning/task_agent_playtesting/#1-telemetry-interface","title":"1. Telemetry Interface","text":"<p>We need to expose a consistent set of metrics to the <code>window</code> object so that an agent (via Playwright or simple browser scripting) can scrape them. - <code>window.telemetry.getMetrics()</code>: Should return:     - <code>money</code>: Current balance.     - <code>gemCollectionCount</code>: Total gems collected in session.     - <code>averageSpeed</code>: Average speed over the last 10 seconds.     - <code>collisionCount</code>: Total number of physical collisions.</p>"},{"location":"planning/task_agent_playtesting/#2-input-simulation-api","title":"2. Input Simulation API","text":"<p>Currently, inputs are tied to keyboard listeners. We need a way to programmatically trigger inputs without actual key events. - <code>window.agentInput.set(direction, value)</code>: e.g., <code>set('up', true)</code>.</p>"},{"location":"planning/task_agent_playtesting/#3-session-recording","title":"3. Session Recording","text":"<p>A way to export the session metrics as a JSON blob at the end of a run for comparison against a baseline.</p>"},{"location":"planning/task_agent_playtesting/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>[ ] Phase 1: Telemetry (Core)<ul> <li>Modify <code>src/core/state.js</code> to track session-based metrics.</li> <li>Add <code>window.telemetry</code> exposure in <code>src/core/game.js</code>.</li> </ul> </li> <li>[ ] Phase 2: Input Hook<ul> <li>Refactor <code>src/core/input.js</code> to allow external overrides.</li> </ul> </li> <li>[ ] Phase 3: Reporting<ul> <li>Add a \"Playtest Summary\" modal/console log that appears when a session ends.</li> </ul> </li> </ol>"},{"location":"planning/task_agent_playtesting/#definition-of-done","title":"Definition of Done","text":"<ul> <li>An agent can successfully move the bulldozer via a script.</li> <li>A JSON report can be generated showing \"Time to $1000\".</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/","title":"Current Plan: Refactoring &amp; Docs","text":"<p>Date: 2025-05-18 (Session Date)</p>"},{"location":"planning/archive/2025-05-18_refactoring/#overview","title":"Overview","text":"<p>We are solidifying the DAMP pipeline and improving project documentation infrastructure.</p>"},{"location":"planning/archive/2025-05-18_refactoring/#changes","title":"Changes","text":""},{"location":"planning/archive/2025-05-18_refactoring/#1-code-maintenance","title":"1. Code Maintenance","text":"<ul> <li>Consolidated <code>cb()</code> Utility: Moved the cache-busting function from scattered files to <code>src/utils/graphics-utils.js</code>.</li> <li>Blender Parenting: Refactored <code>pipeline/blender/bulldozer.py</code> to use object parenting instead of mesh joining. This ensures that individual components (Wheels, Cabin) retain their <code>damp_id</code> contract tags in the exported GLB.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/#2-documentation-system","title":"2. Documentation System","text":"<ul> <li>MkDocs: Setting up <code>mkdocs</code> with the <code>material</code> theme for a professional documentation site.</li> <li>Auto-Formatting: Integrating <code>mdformat</code> to keep documentation consistent.</li> <li>Deployment: Ensuring docs are built and published to <code>dist/docs</code> during PR previews.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/#next-steps","title":"Next Steps","text":"<ul> <li> Verify the new GLB structure in the Asset Viewer.</li> <li> Verify the documentation site build.</li> </ul>"},{"location":"planning/archive/2026-01-07_ui_gameplay_polish/","title":"Plan: UI &amp; Gameplay Polish","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2026-01-07</li> <li>Author: Jules (AI Agent)</li> </ul> <p> Context</p> <p>The project required several refinements to improve visual polish and fix gameplay bugs. Specifically: 1.  Money Mat: The physical \"mat\" and 3D coin piles were causing visual clutter and were deemed unnecessary. 2.  Coin Animation: A more engaging visual feedback for currency collection was requested, specifically animating \"flying coins\" to the UI counter. 3.  Collector Upgrade: The collector logic scaled exponentially, causing the entity to extend infinitely and clip through map walls at high levels.</p> <p> Plan</p> <ol> <li>Remove Money Mat: Delete <code>createCoinPile</code>, <code>updateCoinPile</code>, and related groups from <code>src/core/graphics.js</code>.</li> <li>UI Animation: Implement <code>spawnCoinDrop</code> using DOM elements (<code>.flying-coin</code>) and the Web Animations API to animate coins from world-space to the <code>#money</code> UI element.</li> <li>Collector Fix: Refactor <code>src/entities/collector.js</code> to use linear scaling (<code>50 + (level-2)*50</code>) and cap the length at 500 units.</li> <li>Verification: Add a Playwright script to verify the visual changes.</li> </ol> <p> Execution Log</p> <ul> <li> Cleanup: Removed <code>coinPileGroup</code> and related logic from <code>src/core/graphics.js</code>.</li> <li> Animation: Implemented DOM-based flying coin animation in <code>spawnCoinDrop</code>.</li> <li> Styling: Added <code>.flying-coin</code> class to <code>style.css</code>.</li> <li> Fix: Updated <code>src/entities/collector.js</code> to cap belt length and use linear growth.</li> <li> Verification: Verified via <code>verification/verify_changes.py</code> (flying coins detected).</li> </ul> <p> AI Summary</p> <p>The tasks were successfully completed. The removal of the 3D money pile reduces scene complexity, while the new flying coin animation provides clear, satisfying feedback for the player. The collector upgrade logic is now robust against map boundary clipping.</p>"},{"location":"planning/archive/doc_rewrite/","title":"Plan: Documentation Rewrite","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2025-05-19</li> <li>Author: Jules (AI Agent)</li> </ul> <p> Context</p> <p>The project documentation was fragmented, out of date, and lacked a clear structure. The goal of this task was to perform a \"Full Rewrite\" to consolidate information, establish a clear hierarchy, and implement a maintainable roadmap structure. Additionally, we aimed to \"uplift\" the visual presentation using <code>mkdocs-material</code> features like admonitions and tabs.</p> <p> Plan</p> <ol> <li>Consolidate and Clean Up: Remove duplicate files and archive old plans.</li> <li>Restructure: Organize <code>docs/</code> into logical subdirectories (<code>architecture</code>, <code>troubleshooting</code>, <code>history</code>).</li> <li>Update Content: Rewrite key architectural docs (<code>DAMP_MAINTAINABILITY.md</code>) to reflect the current \"Explicit Contract\" state.</li> <li>Enhance: Add <code>mkdocs-material</code> plugins and formatting.</li> <li>Tooling: Add a pre-commit script to enforce documentation formatting.</li> </ol> <p> Execution Log</p> <ul> <li> Restructuring: Moved files to <code>docs/architecture</code>, <code>docs/guide</code>, etc.</li> <li> Roadmap: Created <code>docs/planning/roadmap.md</code> and archived old plans.</li> <li> Rewrite: Completely rewrote <code>DAMP_MAINTAINABILITY.md</code> to remove outdated \"Proposed\" logic.</li> <li> Uplift: Updated <code>mkdocs.yml</code> with <code>awesome-pages</code>, <code>admonition</code>, and <code>pymdownx.emoji</code>.</li> <li> Tooling: Implemented <code>pipeline/scripts/format_docs.py</code> using <code>uvx</code> and <code>mdformat</code> (resolving dependency conflicts by removing <code>mdformat-admon</code>).</li> <li> Verification: Validated build via <code>task docs:build</code>.</li> </ul> <p> AI Summary</p> <p>The documentation ecosystem has been successfully migrated to a structured, maintainable format.</p> <p>Key Achievements:</p> <ul> <li>Architecture: The \"Four Pillars\" structure (Src, Pipeline, Tools, Assets) is now formally documented.</li> <li>Pipeline: The \"Explicit Contract\" model (using <code>damp_id</code>) is codified as the source of truth, replacing old speculative docs.</li> <li>Visuals: Documentation now uses consistent admonitions, tabs for commands, and icons for navigation.</li> <li>Workflow: A new <code>task docs:format</code> command ensures consistency going forward.</li> </ul> <p>Next Steps for Future Agents:</p> <ul> <li>Refer to <code>docs/architecture/DAMP_MAINTAINABILITY.md</code> for architectural decisions.</li> <li>Use <code>docs/planning/roadmap.md</code> to track future work.</li> <li>Ensure all new docs pass <code>task docs:lint</code>.</li> </ul>"},{"location":"planning/archive/task_scaling_rebalance/","title":"Task: Scaling Rebalance &amp; Progression Tuning","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Type: Rebalance / Feature</li> <li>Dependencies: <code>docs/guide/progression_analysis.md</code></li> </ul> <p> Context</p> <p>Refine the game's progression curve to ensure a satisfying \"Power Fantasy\" loop while maintaining challenge. Resolve the conflict between manual and automatic area unlocking.</p> <p> Plan</p> <ol> <li>Resolve Unlock Logic<ul> <li>Remove the \"Auto Unlock\" feature from <code>gem.js</code>.</li> <li>Keep the Zone Progress notification but change the reward to a large \"Bonus Cash\" drop.</li> </ul> </li> <li>Tune Economy (Inflation)<ul> <li>Increase Gem Values in Zone 3 (100-200 value).</li> </ul> </li> <li>Refactor Physics Scaling (Engine)<ul> <li>Make Density scaling linear.</li> <li>Switch to \"Power Rating\" based Force calculation: <code>Force = 0.012 * 1.25^Level</code>. This provides a stronger acceleration curve than the previous 1.2x.</li> </ul> </li> <li>Adjust Upgrade Curves (Plow &amp; Collector)<ul> <li>Plow: Increase width scaling to <code>+8</code> per level. Wings scale with level.</li> <li>Collector: Ensure Belts visual scaling matches physics scaling.</li> </ul> </li> <li>Cost Curve Smoothing<ul> <li>Change to <code>Cost = Base * (1.3 ^ (Level - 1))</code>.</li> </ul> </li> </ol> <p> Execution Log</p> <ul> <li> Physics Fix: Refactor density to linear, Force to Power-based model.</li> <li> Unlock Logic: Remove auto-unlock and update Shop logic.</li> <li> Economy: Tune Zone 3 gem values.</li> <li> Upgrades: Adjust plow width/wings and smoothing cost curves.</li> <li> Re-tuning: Increased engine power scaling to 1.25x to overcome quadratic mass growth.</li> </ul>"},{"location":"planning/proposals/agent_playtesting/","title":"Agent Playtesting Guide","text":"<p>This document outlines how an AI agent can perform playtesting for the Gem Miner project to verify physics, mechanics, and game balance.</p>"},{"location":"planning/proposals/agent_playtesting/#overview","title":"Overview","text":"<p>Agent playtesting uses an automated \"headless\" environment or a scripted game session to simulate player behavior and collect metrics. This allows us to verify how changes (like physics tuning or gem value adjustments) affect the \"vibe\" and progression without requiring a human to manually play through every build.</p>"},{"location":"planning/proposals/agent_playtesting/#playtesting-methods","title":"Playtesting Methods","text":""},{"location":"planning/proposals/agent_playtesting/#1-headless-physics-verification","title":"1. Headless Physics Verification","text":"<p>Use the <code>verification/measure_scaling.py</code> script (and associated HTML harness) to simulate bulldozer movement and gem collection in a controlled environment. - Purpose: Verifies collision boxes, pushing power, and movement curves. - How to run: <pre><code>python3 verification/measure_scaling.py\n</code></pre></p>"},{"location":"planning/proposals/agent_playtesting/#2-scripted-gameplay-simulation","title":"2. Scripted Gameplay Simulation","text":"<p>By hooking into the <code>window.state</code> and <code>window.bulldozer</code> objects in the browser environment, an agent can \"play\" the game by simulating input commands. - Key Objects:   - <code>window.bulldozer</code>: Current position, speed, and physics properties.   - <code>window.state</code>: Current money, upgrades, and progression.   - <code>initInput()</code>: The input listener can be triggered via keyboard event simulations.</p>"},{"location":"planning/proposals/agent_playtesting/#3-metric-collection","title":"3. Metric Collection","text":"<p>When running a playtest, focus on the following metrics to determine if a change is successful: - Time to Goal: How long it takes to collect $X$ amount of gems. - Movement Fluidity: Number of collisions or \"stuck\" events per minute. - Upgrade ROI: How much the \"Time to Goal\" decreases after a specific upgrade.</p>"},{"location":"planning/proposals/agent_playtesting/#playtesting-workflow-for-agents","title":"Playtesting Workflow for Agents","text":"<ol> <li>Checkout Branch: Create a feature branch for the change.</li> <li>Apply Change: Modify physics or game logic.</li> <li>Run Baseline: Run the verification suite on <code>main</code> to get baseline metrics.</li> <li>Run Test: Run the same suite on the feature branch.</li> <li>Compare &amp; Report: Provide a summary comparing the metrics (e.g., \"Plow Level 3 is 15% faster at clearing the field, but inertia makes cornering harder\").</li> </ol>"},{"location":"planning/proposals/agent_playtesting/#future-goals","title":"Future Goals","text":"<ul> <li>Implement a <code>PlaytestRunner</code> class that can automate multi-minute sessions.</li> <li>Export telemetry data (JSON) from playtest sessions for long-term tracking.</li> </ul>"}]}