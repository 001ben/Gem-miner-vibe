{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation Index","text":"<p>Welcome to the Gem Miner technical documentation.</p>"},{"location":"#guides-reference","title":"\ud83d\udcda Guides &amp; Reference","text":"<ul> <li> Project Structure: Overview of the codebase layout, including source, pipeline, and tools.</li> <li> Taskfile Commands: How to build, run, and verify the project.</li> </ul>"},{"location":"#architecture-damp","title":"\ud83c\udfd7 Architecture (DAMP)","text":"<p>The Distributed Asset &amp; Material Pipeline (DAMP) is the core of our asset generation workflow.</p> <ul> <li> Overview: High-level structure and the \"Four Pillars\".</li> <li> The DAMP Strategy: The \"Explicit Contract\" model and core philosophy.</li> <li> Blender API: How to write asset generation scripts.</li> </ul>"},{"location":"#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":"<ul> <li> Common Errors: Setup and runtime issues.</li> <li> Graphics Troubleshooting: Visual artifacts and rendering fixes.</li> </ul>"},{"location":"#planning","title":"\ud83d\uddd3 Planning","text":"<ul> <li>:material-roadmap: Roadmap: High-level goals and backlog.</li> <li> Current Task: Status of the current active work.</li> <li> History: Past session logs and decision records.</li> </ul>"},{"location":"knowledge/archive/ASSET_PIPELINE/","title":"Asset Pipeline &amp; Material Challenges","text":""},{"location":"knowledge/archive/ASSET_PIPELINE/#current-architecture","title":"Current Architecture","text":"<p>Our \"Programmer CAD\" pipeline currently operates as follows:</p> <ol> <li>Source: Parametric geometry defined in OpenSCAD (<code>.scad</code>).</li> <li>Compilation: OpenSCAD CLI exports the geometry to ASCII STL.</li> <li>Conversion: A custom script (<code>stl2obj.js</code>) converts STL to OBJ.</li> <li>Packaging: <code>obj2gltf</code> converts OBJ to binary GLTF (<code>.glb</code>).</li> </ol>"},{"location":"knowledge/archive/ASSET_PIPELINE/#implemented-strategy-component-based-assembly","title":"Implemented Strategy: Component-Based Assembly","text":"<p>To solve the \"monolithic mesh\" color limitation of STL, we have adopted a Component-Based Assembly strategy.</p> <ul> <li>Workflow:<ul> <li>Instead of one <code>bulldozer.scad</code>, we maintain separate source files:<ul> <li><code>bulldozer_body.scad</code></li> <li><code>bulldozer_tracks.scad</code></li> <li><code>bulldozer_cabin.scad</code></li> </ul> </li> <li>The build pipeline (<code>npm run build:assets</code>) compiles these individually into <code>.glb</code> files.</li> </ul> </li> <li>Runtime Assembly:<ul> <li>The game engine (Three.js) loads these separate assets.</li> <li>They are added to a single <code>THREE.Group</code> container.</li> <li>Colors/Materials: Because each part is a distinct mesh, we can assign different materials to them programmatically (e.g., <code>bodyMesh.material = yellowMaterial</code>, <code>tracksMesh.material = darkMaterial</code>).</li> </ul> </li> </ul>"},{"location":"knowledge/archive/ASSET_PIPELINE/#future-roadmap-advanced-visuals-best-practices","title":"Future Roadmap: Advanced Visuals &amp; Best Practices","text":"<p>As we look to move beyond simple solid colors, here are the challenges and best practices for a \"Programmer CAD\" (Code-first) workflow vs. a traditional Artist workflow.</p>"},{"location":"knowledge/archive/ASSET_PIPELINE/#1-textures-surface-detail","title":"1. Textures &amp; Surface Detail","text":"<p>The Challenge: Standard 3D texturing relies on UV Mapping\u2014unwrapping a 3D object onto a 2D plane so an image can be painted on it. OpenSCAD / CSG (Constructive Solid Geometry) tools do not generate UV maps automatically, and \"unwrapping\" a procedurally generated mesh manually defeats the purpose of an automated pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Triplanar Mapping: Instead of using UVs, use a special shader (or Three.js node material) that projects textures onto the object from the Top, Front, and Side (X, Y, Z axes). This allows you to apply \"Dirt\", \"Rust\", or \"Scratches\" textures to any shape without manual work.</li> <li>Matcaps (Material Capture): Use <code>THREE.MeshMatcapMaterial</code>. This uses a spherical reference image to fake complex lighting and reflection (e.g., chrome, shiny car paint) cheaply. It looks great and requires no UVs.</li> <li>Decals: For specific details (like a \"Hazard Stripe\" or a Logo), use a separate floating mesh or a \"Decal\" geometry placed slightly above the surface, rather than trying to texture the main body.</li> </ul>"},{"location":"knowledge/archive/ASSET_PIPELINE/#2-animations","title":"2. Animations","text":"<p>The Challenge: Traditional game assets use \"Skinned Meshes\" (bones/skeletons) to deform geometry (e.g., a character bending their arm). OpenSCAD exports static rigid meshes. We cannot easily add \"bones\" to an STL file in this pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Hierarchical / Rigid Body Animation: This is what we already support with the Component-Based Assembly.<ul> <li>Example: To animate the plow moving up and down, we do not bend the metal. We verify the <code>plow.glb</code> is its own object, and in the game code, we change its <code>position.y</code> or <code>rotation.x</code>.</li> <li>Example: To animate tracks, we don't deform the rubber. We scroll the texture on the tracks (UV offset animation) or rotate the wheels if they are separate parts.</li> </ul> </li> <li>Code-Driven Motion: All animation should be driven by game state (physics, input), not pre-baked animation clips (like an <code>.fbx</code> file might have). This gives the \"programmer\" ultimate control.</li> </ul>"},{"location":"knowledge/archive/ASSET_PIPELINE/#summary-of-programmer-art-stack","title":"Summary of \"Programmer Art\" Stack","text":"Feature Traditional Workflow (Blender/Maya) Our Workflow (OpenSCAD/Three.js) Geometry Hand-modeled polygons Code-defined primitives (CSG) Colors Texture Maps / Vertex Paint Separate Parts / Runtime Materials Textures Manual UV Unwrapping Triplanar Mapping / Matcaps Animation Skeletal Rigging / Keyframes Hierarchical Code Manipulation <p>Next Steps Recommendation:</p> <ol> <li>Stick to solid colors for now to keep the style clean (e.g., \"Low Poly\" aesthetic).</li> <li>If detail is needed, explore Triplanar Mapping shaders to add noise/grit without needing asset changes.</li> <li>For the plow animation, ensure the plow is a separate asset from the body so it can be moved independently in code.</li> </ol>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/","title":"Tutorial: The Bulldozer Renderer","text":""},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#1-the-high-level-goal","title":"1. The High-Level Goal","text":"<p>This file is responsible for:</p> <ol> <li>Loading the 3D model of the bulldozer.</li> <li>Painting it (creating textures via code, so no image files are needed).</li> <li>Animating the tank tracks so they look like they are rolling.</li> <li>Syncing the visual position with the physics body (Matter.js).</li> </ol>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#2-generating-textures-procedurally","title":"2. Generating Textures \"Procedurally\"","text":"<p>Instead of loading JPG or PNG images (which takes time and bandwidth), this code \"draws\" its own textures using a virtual HTML Canvas.</p> <p>Function: <code>createProceduralTexture(type)</code></p> <ul> <li>How it works: It creates a hidden <code>&lt;canvas&gt;</code> element in memory, gets a 2D drawing context (<code>ctx</code>), and draws shapes.</li> <li>The \"Tracks\" Texture: It draws a dark background and then loops to draw chevron/V-shapes. This creates the tread pattern.</li> <li>The \"Body\" Texture: It draws a yellow square, then scatters random noise (dots) and rust spots to make it look like weathered metal.</li> <li>Three.js Conversion: Finally, <code>new THREE.CanvasTexture(canvas)</code> turns that drawing into something the 3D engine can wrap around a shape.</li> </ul> <pre><code>// Example logic simplified:\nif (type === 'tracks') {\n    ctx.fillStyle = '#333';\n    // Draw zig-zag lines for treads...\n}\nreturn new THREE.CanvasTexture(canvas);\n</code></pre>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#3-the-shader-magic-advanced","title":"3. The Shader Magic (Advanced)","text":"<p>Standard 3D models need \"UV Maps\" (instructions on how to wrap a 2D image around a 3D object). This file uses a clever trick called Triplanar Mapping to avoid needing perfect UVs.</p> <p>Function: <code>enhanceMaterialWithTriplanar(...)</code></p> <ul> <li>What is a Shader? A shader is a small program that runs on your Graphics Card (GPU) to decide the color of every single pixel.</li> <li>The Trick: It intercepts the standard Three.js material code (<code>onBeforeCompile</code>) and injects custom logic.</li> <li>Triplanar Logic: Instead of stretching a texture, it projects the texture from three directions (Top, Side, Front) and blends them together.</li> <li>Scrolling: For the tracks, it adds a <code>uTime</code> variable to slide the texture coordinates, making the treads look like they are moving without actually moving the geometry.</li> </ul>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#4-the-main-class-bulldozerrenderer","title":"4. The Main Class: <code>BulldozerRenderer</code>","text":""},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-constructor","title":"The Constructor","text":"<p>When <code>new BulldozerRenderer(scene)</code> is called:</p> <ol> <li>It creates a <code>THREE.Group</code>. Think of this as an invisible box that will hold all the bulldozer parts (body, glass, tracks).</li> <li>It creates a <code>GLTFLoader</code>. This is the tool that knows how to read <code>.glb</code> (3D model) files.</li> <li>It prepares empty lists (<code>animatedInstances</code>) to track things that need to move every frame.</li> </ol>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-loadurl-method","title":"The <code>load(url)</code> method","text":"<p>This is the heavy lifter. It fetches the file and organizes the parts.</p> <ol> <li>Finding Parts: It loops through every object in the 3D file:<ul> <li>If the name contains \"Bulldozer_Body\", it keeps it as the chassis.</li> <li>If the name contains \"Asset_TrackLink\", it keeps track of track link to load.</li> <li>If the name contains \"Asset_TrackPath\", it reads the mathematical points to know the shape of the tracks (oval-ish).</li> </ul> </li> <li>Applying Materials: It creates the shiny glass material and the rough metal material (using the procedural textures from step 2).</li> <li>Building Tracks (InstancedMesh):<ul> <li>Instead of creating 50 separate 3D objects for the track links (which is slow), it uses <code>InstancedMesh</code>.</li> <li>This tells the GPU: \"Draw this one shape 50 times at these 50 different positions.\" It's a huge performance optimization.</li> <li>It uses <code>THREE.CatmullRomCurve3</code> to calculate a smooth path along the points found in the file.</li> </ul> </li> </ol>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-setposeposition-angle-method","title":"The <code>setPose(position, angle)</code> method","text":"<p>This is the bridge between the Physics world (Matter.js) and the Visual world (Three.js).</p> <ul> <li>Matter.js (2D) calculates where the box is.</li> <li>Three.js (3D) needs to know where to draw it.</li> <li>This function copies the X/Y from physics to X/Z in 3D (since Y is \"up\" in 3D) and applies the rotation.</li> </ul> <pre><code>setPose(position, angle) {\n    this.group.position.set(position.x, 0, position.y); // Map 2D -&gt; 3D\n    this.group.rotation.y = -angle; // Rotate the model\n}\n</code></pre>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-updatedelta-method","title":"The <code>update(delta)</code> method","text":"<p>This runs 60 times a second (the game loop).</p> <ol> <li>Shader Time: It increases the <code>uTime</code> value so the track textures keep scrolling.</li> <li>Track Movement: It calculates the position of every single track link along the curve.<ul> <li><code>track.curve.getPointAt(t)</code>: \"Where is the link at 50% along the curve?\"</li> <li><code>track.curve.getTangentAt(t)</code>: \"Which way should it face?\"</li> <li>It updates the matrix (position+rotation) for all 50 track links instantly.</li> </ul> </li> </ol>"},{"location":"knowledge/archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#summary","title":"Summary","text":"<ul> <li><code>bulldozer.js</code> is the \"Brain\" (Physics, Collision).</li> <li><code>bulldozer_render.js</code> is the \"Costume\" (Graphics).</li> <li>It generates its own \"fabric\" (textures) via code.</li> <li>It uses a \"Green Screen\" trick (Shaders) to animate the texture scrolling.</li> <li>It listens to the \"Brain\" every frame via <code>setPose</code> to know where to stand.</li> </ul>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/","title":"Graphics System Design &amp; Analysis","text":""},{"location":"knowledge/archive/GRAPHICS_DESIGN/#current-implementation","title":"Current Implementation","text":"<p>The current graphics implementation relies on a \"Programmer Art\" approach where 3D visuals are generated procedurally at runtime using Three.js primitives (<code>BoxGeometry</code>, <code>TorusGeometry</code>, <code>IcosahedronGeometry</code>).</p>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/#architecture","title":"Architecture","text":"<ul> <li>State Synchronization: The <code>updateGraphics()</code> loop iterates through all Matter.js physics bodies every frame.</li> <li>1:1 Mapping: Each physics body part (including compound body parts) creates and manages its own independent Three.js mesh.</li> <li>Procedural Generation: Visuals like the Bulldozer, Plow, and Collector are constructed by combining simple geometric shapes in code. Texture atlases or external models are not used.</li> </ul>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/#deviation-from-standard-practices","title":"Deviation from Standard Practices","text":"<p>Industry-standard web game development (using engines like Three.js, Babylon, or PlayCanvas) typically follows different patterns:</p> <ol> <li> <p>Asset-Based Workflow:</p> <ul> <li>Standard: Artists create models in tools like Blender/Maya/3ds Max and export them as <code>GLTF</code>/<code>GLB</code> files. These assets contain optimized geometry, UV maps, materials, and animations.</li> <li>Current: Geometry is hard-coded. Adjusting the \"look\" (e.g., curving a plow) requires complex trigonometric math and geometry manipulation in code rather than moving vertices in an editor.</li> </ul> </li> <li> <p>Scene Graph Hierarchy:</p> <ul> <li>Standard: A single visual root object represents a game entity (e.g., a Tank). Physics bodies update the root's transform, and child nodes (turret, wheels) are animated relative to that root.</li> <li>Current: Every physics sub-part (chassis, wheel, plow) drives its own mesh directly. This ensures tight physics matching but makes complex visual articulation (like suspension or smooth interpolation) harder to implement.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Standard: Use InstancedMesh for identical objects (like Gems). This allows rendering thousands of items with a single draw call.</li> <li>Current: Each Gem is a separate <code>Mesh</code> object. While Three.js handles frustum culling, the CPU overhead of updating thousands of individual scene graph nodes every frame limits the maximum gem density.</li> </ul> </li> </ol>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/#opportunities-for-improvement","title":"Opportunities for Improvement","text":""},{"location":"knowledge/archive/GRAPHICS_DESIGN/#1-asset-pipeline-integration","title":"1. Asset Pipeline Integration","text":"<p>Moving to a GLTF loader workflow would immediately improve visual fidelity.</p> <ul> <li>Action: Create a <code>AssetManager</code> class to load <code>.glb</code> files.</li> <li>Benefit: \"Real\" modeled plows with proper curves, metallic textures, and baked ambient occlusion.</li> </ul>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/#2-instanced-rendering-for-gems","title":"2. Instanced Rendering for Gems","text":"<p>The \"Gem Fields\" concept requires high object counts.</p> <ul> <li>Action: Replace individual <code>IcosahedronGeometry</code> meshes with a single <code>THREE.InstancedMesh</code> managed by a specialized <code>GemRenderer</code> system.</li> <li>Benefit: Could easily support 10,000+ gems at 60fps, allowing for massive \"ocean of gems\" gameplay.</li> </ul>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/#3-decoupled-rendering-state","title":"3. Decoupled Rendering State","text":"<p>Currently, visuals snap to physics state.</p> <ul> <li>Action: Implement a state interpolation buffer. Render at screen refresh rate (e.g., 144Hz) while physics runs at fixed steps (60Hz), interpolating positions <code>(prev * (1-alpha) + curr * alpha)</code>.</li> <li>Benefit: Eliminates micro-stutter and provides buttery smooth motion, even if physics frames drop.</li> </ul>"},{"location":"knowledge/archive/GRAPHICS_DESIGN/#4-shader-effects","title":"4. Shader Effects","text":"<ul> <li>Action: Replace standard materials with custom ShaderMaterials for effects like \"Glow\" on high-value gems, \"Heat distortion\" behind the engine, or dynamic tracks that fade using a fragment shader time uniform instead of transparency updates.</li> </ul>"},{"location":"knowledge/archive/SCAD_VS_BLENDER/","title":"Asset Pipeline: OpenSCAD vs. Blender","text":"<p>We originally explored two different pipelines for generating 3D game assets. We have decided to standardize on the Blender pipeline. This document summarizes the differences, benefits, and reasons for this decision.</p>"},{"location":"knowledge/archive/SCAD_VS_BLENDER/#1-the-openscad-pipeline-programmers-cad","title":"1. The OpenSCAD Pipeline (\"Programmer's CAD\")","text":"<p>Approach:</p> <ul> <li>Define geometry using Constructive Solid Geometry (CSG) in <code>.scad</code> files.</li> <li>Compile to STL -&gt; OBJ -&gt; GLTF using a chain of tools (<code>openscad</code>, <code>obj2gltf</code>).</li> <li>Procedural textures generated at runtime in the client.</li> </ul> <p>Code Snippet (<code>bulldozer_body.scad</code>):</p> <pre><code>// Parametric definition\nbody_width = 12;\nbody_length = 16;\nbody_height = 5;\n\n// CSG Operations\ntranslate([-body_width/2, -body_length/2, 4/2])\n    cube([body_width, body_length, body_height]);\n</code></pre> <p>Pros:</p> <ul> <li>Parametric: Easy to adjust dimensions via variables.</li> <li>Git-Friendly: Source files are pure text.</li> <li>Precise: Exact mathematical alignment.</li> </ul> <p>Cons:</p> <ul> <li>Limited Export: OpenSCAD exports raw geometry (STL) without UVs, Materials, or scene hierarchy.</li> <li>Rendering Issues: The generated meshes often have bad normals or topology for game engines.</li> <li>No Animations: Cannot export armatures, keyframes, or separate parts easily without splitting into many files.</li> <li>Material Complexity: Requires custom \"Triplanar Mapping\" shaders in the client because the model lacks UV coordinates.</li> </ul>"},{"location":"knowledge/archive/SCAD_VS_BLENDER/#2-the-blender-pipeline-game-ready-assets","title":"2. The Blender Pipeline (\"Game-Ready Assets\")","text":"<p>Approach:</p> <ul> <li>Use Python scripting inside Blender (<code>bpy</code>) to generate geometry programmatically.</li> <li>Export directly to <code>.glb</code> (GLTF binary) which supports hierarchy, materials, and animations.</li> <li>Use standard Three.js loaders in the client.</li> </ul> <p>Code Snippet (<code>bulldozer.py</code>):</p> <pre><code>import bpy\n\n# Create Mesh\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 1.0))\nbody = bpy.context.object\nbody.name = \"Bulldozer_Body\"\nbody.scale = (2.5, 4.0, 1.5)\n\n# Assign Material\nmat = bpy.data.materials.new(name=\"YellowPaint\")\nbody.data.materials.append(mat)\n\n# Export\nbpy.ops.export_scene.gltf(filepath=\"bulldozer.glb\", export_format='GLB')\n</code></pre> <p>Pros:</p> <ul> <li>Rich Assets: Exports a complete scene with node hierarchy, proper names, and material slots.</li> <li>UV Unwrapping: Can automatically project UVs (<code>bpy.ops.uv.smart_project</code>), allowing standard textures.</li> <li>Animation Support: Capable of baking animations and skeletal rigs.</li> <li>Debugging: The generated file can be opened in Blender GUI for visual inspection.</li> <li>Standard Rendering: Works with standard <code>MeshStandardMaterial</code> without shader hacks.</li> </ul> <p>Cons:</p> <ul> <li>Dependency: Requires Blender to be installed on the build machine.</li> <li>Complexity: The Blender Python API is more complex than SCAD.</li> </ul>"},{"location":"knowledge/archive/SCAD_VS_BLENDER/#conclusion-why-blender","title":"Conclusion: Why Blender?","text":"<p>We chose the Blender pipeline because it produces Game-Ready Assets. The OpenSCAD pipeline required too much runtime \"patching\" (custom shaders for triplanar mapping, manual material assignment, lack of object hierarchy). The Blender pipeline gives us a standard GLTF file that \"just works\" in Three.js, while still maintaining the benefits of procedural generation via Python scripts.</p>"},{"location":"knowledge/history/GEMINI_2025_12/","title":"Gemini Session Summary: DAMP Pipeline Evolution","text":"<p>This document tracks the key technical findings, architectural decisions, and critical \"NO\" moments (course corrections) during the development of the Distributed Asset &amp; Material Pipeline (DAMP).</p>"},{"location":"knowledge/history/GEMINI_2025_12/#the-core-achievement-the-explicit-contract","title":"\ud83d\ude80 The Core Achievement: The Explicit Contract","text":"<p>We successfully transitioned from an Implicit Pipeline (guessing mesh names like <code>Cube001</code>) to an Explicit Contract Model.</p> <ul> <li>Blender explicitly tags materials and objects with <code>damp_id</code>.</li> <li>JSON defines properties using those IDs.</li> <li>Renderer strictly enforces the contract (ID or Magenta Error).</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#key-technical-findings","title":"\ud83d\udee0 Key Technical Findings","text":""},{"location":"knowledge/history/GEMINI_2025_12/#1-parenting-joining","title":"1. Parenting &gt; Joining","text":"<ul> <li>Discovery: <code>bpy.ops.object.join()</code> in Blender destroys Object-level metadata and forces Three.js to split primitives at runtime, causing race conditions.</li> <li>Solution: Use Parenting. It preserves the logical hierarchy, keeps unique names/IDs intact, and allows for independent material tuning without complex \"heuristic\" code.</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#2-material-level-tagging","title":"2. Material-Level Tagging","text":"<ul> <li>Discovery: Custom properties on Materials are more resilient than on Objects. Even if geometry is merged, Three.js preserves material slots.</li> <li>Impact: Tagging materials directly (<code>MAT_Glass[\"damp_id\"] = \"cabin\"</code>) eliminated 50+ lines of brittle string-matching code in the renderer.</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#4-the-four-pillars-layout","title":"4. The \"Four Pillars\" Layout","text":"<ul> <li>Discovery: Keeping source, build tools, and distribution assets in a flat or overlapping structure leads to deployment risks and high cognitive load.</li> <li>Solution: Standardize on a Domain-Split structure: <code>src/</code> (App), <code>pipeline/</code> (Factory), <code>tools/</code> (DX), and <code>assets/</code> (Output). This isolates the \"Source of Truth\" from the \"Distribution Artifacts.\"</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#5-explicit-relative-paths-bare-specifiers","title":"5. Explicit Relative Paths &gt; Bare Specifiers","text":"<ul> <li>Discovery: Relying on <code>importmap</code> for internal project modules (like <code>core/</code>) makes the codebase brittle and harder to debug in standard environments without custom server configs.</li> <li>Solution: Use standard relative paths (<code>./</code>, <code>../</code>) for all internal modules. Save the <code>importmap</code> for external CDN-hosted dependencies (Three.js, React).</li> </ul>"},{"location":"knowledge/history/GEMINI_2025_12/#the-no-wall-critical-corrections","title":"\ud83d\uded1 The \"NO\" Wall: Critical Corrections","text":"<p>Significant moments where the user rejected a path, leading to a better architecture.</p> <ol> <li>NO to Local Libs: I initially tried to bundle Three.js locally in the viewer.<ul> <li>Correction: \"We switched to unpkg.\"</li> <li>Lesson: Keep the repo lean; use CDNs for standardized dependencies.</li> </ul> </li> <li>NO to \"One-Size-Fits-All\" Texturing: I initially applied one texture to the whole GLB.<ul> <li>Correction: \"Our actual bulldozer uses different textures per component.\"</li> <li>Lesson: The pipeline must support granular, component-level material mapping.</li> </ul> </li> <li>NO to Manual Scaling: I tried to fix alignment by manually setting scales/positions in JS.<ul> <li>Correction: This resulted in \"tiny bodies and giant tracks.\"</li> <li>Lesson: Bake transforms in the source (Blender). Vertices should be normalized at <code>(1,1,1)</code> before export.</li> </ul> </li> <li>NO to Heuristic Fallbacks: I added <code>if (name.includes(\"Cube\"))</code> to handle Blender's generic names.<ul> <li>Correction: \"Don't use fallbacks at all. Use IDs or error.\"</li> <li>Lesson: Reliability comes from explicit contracts, not clever guessing.</li> </ul> </li> <li>NO to Lazy Refactoring: I used <code>// ... logic here</code> placeholders in a file write.<ul> <li>Correction: \"Please don't use '... this logic' when making edit changes.\"</li> <li>Lesson: Always provide complete, functional source code.</li> </ul> </li> <li>NO to Internal Import Maps: I tried to map <code>core/</code> and <code>entities/</code> via <code>importmap</code> to \"fix\" the structure split.<ul> <li>Correction: \"Let's whack a mole the errors independently.\"</li> <li>Lesson: Don't mask path issues with specifier mappings; fix the source imports to use standard relative paths.</li> </ul> </li> <li>NO to \"Summary First\" Workflow: I summarized changes multiple times before actually calling the tool to apply them.<ul> <li>Correction: \"Apply changes to the file and THEN summarise your changes.\"</li> <li>Lesson: The tool call is the primary action; the text output is the confirmation of that action.</li> </ul> </li> </ol>"},{"location":"knowledge/history/GEMINI_2025_12/#maintainability-checklist","title":"\ud83c\udfd7 Maintainability Checklist","text":"<ul> <li> Modular Build: 5-step process orchestrated by Taskfile.</li> <li> Asset Isolation: Textures and models separated from core game logic.</li> <li> Clean Pillar Split: Source, Pipeline, Tools, and Assets isolated in the filesystem.</li> <li> Standard Imports: Pure relative module resolution without specifier hacks.</li> <li> Verification: <code>task build:verify</code> provides a raw look at the GLB \"Contract\" before it hits the web.</li> <li> Zero-Cache: Dynamic import maps and server headers ensure the latest code is always live.</li> </ul> <p>Session Date: Thursday 18 December 2025</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/","title":"Common Errors &amp; Troubleshooting","text":""},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#asset-viewer","title":"Asset Viewer","text":""},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#failed-to-load-resource-script-unknown-source","title":"<code>Failed to load resource: &lt;SCRIPT&gt; unknown source</code>","text":"<p>Symptoms</p> <ul> <li>The asset viewer loads the UI but the 3D scene is empty.</li> <li>The console (or on-screen log) shows \"Failed to load resource\" pointing to the main module script.</li> <li>\"Three.js imported successfully\" is NOT logged.</li> </ul> <p>Cause: This error occurs when the browser cannot resolve one of the JavaScript modules imported by the viewer. Common reasons include:</p> <ol> <li>Incorrect Server Root: The web server was started from the <code>verification/</code> directory instead of the repository root. This makes <code>../js/</code> and <code>../node_modules/</code> inaccessible (404).</li> <li>Missing Dependencies: <code>npm install</code> has not been run, so <code>node_modules</code> is missing or incomplete.</li> <li>Deployment Path Issues: In a deployed environment (e.g., GitHub Pages), the relative paths to <code>js/</code> or <code>node_modules/</code> might be incorrect if the build script didn't rewrite them properly.</li> </ol> <p>Solution</p> <p>Local Development: Use the Taskfile commands to start the viewer from the correct root:</p> <pre><code>task damp:viewer\n</code></pre> <p>Deployment: Check the <code>pr-preview.yml</code> workflow to ensure it copies source files to the <code>dist/</code> folder and rewrites paths (<code>sed</code>) in <code>index.html</code>.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#failed-to-load-resource-bulldozer_componentsglb-404","title":"<code>Failed to load resource: ... bulldozer_components.glb</code> (404)","text":"<p>Cause: The 3D assets have not been built locally.</p> <p>Solution</p> <p>Run the asset build task:</p> <pre><code>task build:assets\n</code></pre> <p>Note: The asset viewer handles this gracefully by logging a warning, but the model will not appear.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#graphics-glitches","title":"Graphics Glitches","text":""},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#fan-like-vertical-tracks","title":"\"Fan-like\" Vertical Tracks","text":"<p>Cause: The track link mesh orientation in the GLB does not match the animation logic (Three.js <code>lookAt</code> expects Z-forward).</p> <p>Solution</p> <p>Use the \"Track Adj\" controls in the Asset Viewer to set Z-Rotation to 270.</p>"},{"location":"knowledge/troubleshooting/COMMON_ERRORS/#flickering-vanishing-tracks","title":"Flickering / Vanishing Tracks","text":"<p>Cause: Gimbal lock when the track tangent aligns with the World Y-axis.</p> <p>Solution</p> <p>Ensure the \"Up\" vector in the Asset Viewer is set to X (Axle).</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/","title":"Graphics Troubleshooting: The \"Striped Shadow\" Artifact","text":""},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-issue","title":"The Issue","text":"<p>In 3D rendering, you may observe weird, striped shadow patterns across surfaces that look like texture glitches or blinds. This is often described as \"Shadow Acne\" or \"Self-Shadowing Artifacts.\"</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-cause","title":"The Cause","text":"<p>This is a fundamental limitation of Shadow Mapping.</p> <ol> <li>Depth Map Resolution: The light source renders the scene depth to a texture (the Shadow Map). This texture has limited resolution (e.g., 1024x1024 pixels).</li> <li>Quantization: When checking if a pixel on the screen is in shadow, the engine compares the pixel's depth to the value stored in the shadow map.</li> <li>The Glitch: Due to limited precision (quantization) and the angle of the light, a flat surface might calculate its depth as slightly behind the value in the shadow map for some pixels and in front for others. This causes the surface to cast a shadow on itself in a striped pattern.</li> </ol>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#the-fix","title":"The Fix","text":"<p>We need to tune the Shadow Bias.</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#1-bias-offset","title":"1. Bias (Offset)","text":"<p>This pushes the shadow slightly deeper/away from the light.</p> <ul> <li>Too Low: Acne remains.</li> <li>Too High: \"Peter Panning\" (shadows detach from the object).</li> </ul>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#2-normal-bias","title":"2. Normal Bias","text":"<p>This pushes the shadow lookup coordinate along the surface normal. This is very effective for curved or low-poly geometry (like our programmer art).</p>"},{"location":"knowledge/troubleshooting/GRAPHICS_TROUBLESHOOTING/#implementation-in-threejs","title":"Implementation in Three.js","text":"<pre><code>const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\ndirLight.castShadow = true;\n\n// The Fix:\ndirLight.shadow.bias = -0.0005;      // Slight offset to remove acne\ndirLight.shadow.normalBias = 0.05;   // Pushes shadow based on surface angle\n</code></pre> <p>We have applied this fix to <code>asset_viewer.html</code>.</p>"},{"location":"living/architecture/BLENDER_API/","title":"Blender Python API","text":"<p>The <code>pipeline/blender/</code> directory contains Python scripts that generate game assets. These scripts run in a headless Blender instance via <code>task build:assets</code>.</p>"},{"location":"living/architecture/BLENDER_API/#quick-start","title":"\u26a1 Quick Start","text":"<p>To create a new asset, create a file <code>pipeline/blender/my_asset.py</code>.</p> <pre><code>import bpy\nfrom mathutils import Vector\n\n# 1. Setup\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# 2. Generate Geometry\nbpy.ops.mesh.primitive_cube_add(size=2)\nobj = bpy.context.object\n\n# 3. Apply Contract (Tagging)\nobj[\"damp_id\"] = \"my_cube\"\n\n# 4. Cleanup (UVs, Shading)\nbpy.ops.object.shade_smooth()\n</code></pre>"},{"location":"living/architecture/BLENDER_API/#best-practices","title":"\ud83d\udcda Best Practices","text":""},{"location":"living/architecture/BLENDER_API/#the-damp_id","title":"The <code>damp_id</code>","text":"<p>Always tag your objects. This is how you will find them in the game code.</p> <pre><code># Good\nobj[\"damp_id\"] = \"turret_barrel\"\n\n# Bad (Relying on name)\nobj.name = \"TurretBarrel\"\n</code></pre>"},{"location":"living/architecture/BLENDER_API/#parenting","title":"Parenting","text":"<p>Use parenting to create complex hierarchies without merging geometry.</p> <pre><code># Create Parent\nbpy.ops.mesh.primitive_cube_add()\nparent = bpy.context.object\nparent[\"damp_id\"] = \"tank_body\"\n\n# Create Child\nbpy.ops.mesh.primitive_cylinder_add()\nchild = bpy.context.object\nchild[\"damp_id\"] = \"tank_turret\"\n\n# Link\nchild.parent = parent\n</code></pre>"},{"location":"living/architecture/BLENDER_API/#materials","title":"Materials","text":"<p>You can create placeholder materials in Blender. The Game Engine will likely replace them, but they are useful for tagging.</p> <pre><code>mat = bpy.data.materials.new(name=\"GlassMaterial\")\nmat[\"damp_id\"] = \"glass\"  # &lt;--- Important!\nobj.data.materials.append(mat)\n</code></pre>"},{"location":"living/architecture/BLENDER_API/#debugging","title":"\ud83d\udee0 Debugging","text":"<p>Since the pipeline runs headless, debugging can be tricky.</p> <p>Open the GLB</p> <p>The easiest way to debug is to open the generated <code>.glb</code> file (in <code>dist/assets/models/</code>) using a tool like gltf-viewer.donmccurdy.com or Blender itself.</p> <p>Run Manually</p> <p>You can run the script inside Blender interactively: 1. Open Blender. 2. Go to the Scripting tab. 3. Open your <code>.py</code> file. 4. Click \"Run Script\".</p>"},{"location":"living/architecture/DAMP/","title":"The DAMP Strategy","text":"<p>Distributed Asset &amp; Material Pipeline</p> <p> Core Philosophy</p> <p>Explicit &gt; Implicit</p> <p>We never rely on \"Implicit Logic\" (guessing mesh names like <code>Cube001</code>, assuming default alignments, or relying on runtime discovery). We rely on Explicit Contracts defined by <code>damp_id</code>.</p>"},{"location":"living/architecture/DAMP/#the-explicit-contract","title":"\ud83e\udd1d The Explicit Contract","text":"<p>The pipeline relies on a strict contract between the Provider (Blender) and the Consumer (Three.js).</p> Role Responsibility Mechanism Provider (Blender) Tag specific meshes and materials with a permanent ID. <code>obj[\"damp_id\"] = \"chassis\"</code> Artifact (GLB) Carry these IDs safely through the export process. <code>mesh.userData.damp_id</code> Consumer (Game) Find objects solely by ID, ignoring hierarchy or names. <code>findBodyPart(\"chassis\")</code>"},{"location":"living/architecture/DAMP/#why","title":"Why?","text":"<p>Traditional pipelines break when an artist (or script) changes the hierarchy. If <code>Cube001</code> becomes <code>Cube001.001</code> after a boolean operation, code like <code>scene.getObjectByName(\"Cube001\")</code> fails. With DAMP, the object name is irrelevant. Only the <code>damp_id</code> matters.</p>"},{"location":"living/architecture/DAMP/#architectural-decisions","title":"\ud83c\udfd7 Architectural Decisions","text":""},{"location":"living/architecture/DAMP/#1-parenting-over-joining","title":"1. Parenting over Joining","text":"<p>Rule</p> <p>Never use <code>bpy.ops.object.join()</code> for logical components.</p> <p>Rationale: Joining meshes destroys object-level metadata. If you join a \"Glass\" cabin with a \"Steel\" body, you lose the ability to easily separate them at runtime. Solution: Parent components to a main body. The renderer traverses the children and checks their <code>damp_id</code>.</p>"},{"location":"living/architecture/DAMP/#2-material-level-tagging","title":"2. Material-Level Tagging","text":"<p>Rule</p> <p>Tag Materials (<code>mat[\"damp_id\"]</code>) in addition to Objects.</p> <p>Rationale: Three.js preserves material slots even if geometry is merged. This allows us to identify \"Glass\" parts even if they are part of a larger mesh.</p>"},{"location":"living/architecture/DAMP/#3-baked-transforms","title":"3. Baked Transforms","text":"<p>Rule</p> <p>Bake Scale and Rotation in Blender.</p> <p>Rationale: Runtime rotation fixes (e.g., <code>mesh.rotation.x = -Math.PI/2</code>) often lead to \"Tiny Bodies and Giant Tracks\" bugs when physics and graphics desync. Solution: We ensure that <code>(0,0,0)</code> rotation in Blender corresponds to <code>(0,0,0)</code> in the game engine (Z-Up to Y-Up conversion is handled during export/import).</p>"},{"location":"living/architecture/DAMP/#component-lifecycle","title":"\ud83d\udd04 Component Lifecycle","text":"<p>The standard lifecycle for an asset-based entity (like the <code>BulldozerRenderer</code>):</p>  Init Load Setup Update <p>Physics body is created immediately (invisible). The game can start simulating physics before graphics are loaded.</p> <p><code>BulldozerRenderer</code> fetches the <code>.glb</code> file asynchronously. It checks <code>catalog.json</code> to know which file to load.</p> <ol> <li>Traverse: Iterate through all child meshes.</li> <li>Identify: Check <code>userData.damp_id</code>.</li> <li>Extract:<ul> <li><code>track_path</code>: Extract curve data for tread animation.</li> <li><code>chassis</code>: Apply standard materials.</li> <li><code>glass</code>: Apply transparent materials.</li> </ul> </li> </ol> <p>Every frame, the root Mesh position and rotation are snapped to the Physics Body.</p>"},{"location":"living/architecture/OVERVIEW/","title":"Architecture Overview","text":"<p> Roadmap</p> <p>This document outlines the high-level structure of the Gem Miner codebase and the philosophy behind the \"Distributed Asset &amp; Material Pipeline\" (DAMP).</p>"},{"location":"living/architecture/OVERVIEW/#the-four-pillars","title":"\ud83c\udfdb The Four Pillars","text":"<p>To ensure maintainability and strict separation of concerns, the project is divided into four distinct domains.</p> <pre><code>graph TD\n    SRC[\":material-code-json: src/\"] --&gt;|Runtime Logic| GAME(Game Engine)\n    PIPE[\":material-factory: pipeline/\"] --&gt;|Asset Generation| ASSETS(Compiled Assets)\n    TOOLS[\":material-tools: tools/\"] --&gt;|Verification| VIEWER(Asset Viewer)\n    CONF[\":material-file-cog: assets/\"] --&gt;|Configuration| PIPE\n\n    style SRC fill:#e1f5fe,stroke:#01579b\n    style PIPE fill:#f3e5f5,stroke:#4a148c\n    style TOOLS fill:#e8f5e9,stroke:#1b5e20\n    style CONF fill:#fff3e0,stroke:#e65100\n</code></pre>"},{"location":"living/architecture/OVERVIEW/#1-game-source-src","title":"1.  Game Source (<code>src/</code>)","text":"<p>The Runtime Application. This is the standard ES6 JavaScript game code. It follows a strict rule: It consumes assets, it never generates them.</p> <ul> <li>Core: <code>src/core/</code> (Physics, Graphics, UI, Input)</li> <li>Entities: <code>src/entities/</code> (Bulldozer, Gems, Map)</li> </ul>"},{"location":"living/architecture/OVERVIEW/#2-pipeline-pipeline","title":"2.  Pipeline (<code>pipeline/</code>)","text":"<p>The Asset Factory. This is the \"Source of Truth\" for all visual content. Unlike traditional workflows where artists push binary <code>.blend</code> files, we define assets as Python Scripts.</p> <ul> <li>Blender Scripts: <code>pipeline/blender/</code> (Geometry generation)</li> <li>Texture Scripts: <code>pipeline/textures/</code> (Procedural texture generation)</li> </ul>"},{"location":"living/architecture/OVERVIEW/#3-developer-tools-tools","title":"3.  Developer Tools (<code>tools/</code>)","text":"<p>Standalone applications for verification and debugging.</p> <ul> <li>Asset Viewer: <code>tools/viewer/</code> (A dedicated app to inspect GLBs and Material Contracts)</li> <li>Physics Playground: <code>tools/physics-playground/</code> (Headless physics tuning)</li> </ul>"},{"location":"living/architecture/OVERVIEW/#4-asset-configuration-assets","title":"4.  Asset Configuration (<code>assets/</code>)","text":"<p>Input data and configuration files.</p> <ul> <li>Contracts: <code>assets/configs/</code> (JSON files defining material properties)</li> <li>Reference: <code>assets/source/</code> (Reference images or data)</li> </ul>"},{"location":"living/architecture/OVERVIEW/#the-pipeline-flow","title":"\ud83d\udd04 The Pipeline Flow","text":"<p>The build process transforms Python scripts into optimized GLTF artifacts.</p> <pre><code>sequenceDiagram\n    participant P as Python Script\n    participant B as Blender (Headless)\n    participant C as Compiler\n    participant G as Game Runtime\n\n    P-&gt;&gt;B: Execute Geometry Logic\n    Note over B: Apply Modifiers&lt;br&gt;UV Unwrap&lt;br&gt;Assign damp_id\n    B-&gt;&gt;C: Export GLB\n    C-&gt;&gt;C: Update catalog.json\n    C-&gt;&gt;G: Load Asset (via Fetch)\n</code></pre> <ol> <li>Generation: <code>task build:assets</code> runs Blender in the background.</li> <li>Tagging: Scripts inject a <code>damp_id</code> custom property into meshes and materials.</li> <li>Compilation: The compiler generates a <code>.glb</code> file and updates the <code>catalog.json</code> index.</li> <li>Runtime: The game fetches the GLB and applies materials based on the Explicit Contract (see DAMP Strategy).</li> </ol>"},{"location":"living/guide/PROJECT_STRUCTURE/","title":"Project Structure","text":"<p>Last Updated: 2025-05-19</p> <p>The project follows a \"Modern Standard\" structure to separate source code, build pipelines, and developer tools.</p>"},{"location":"living/guide/PROJECT_STRUCTURE/#directory-layout","title":"Directory Layout","text":"<ul> <li><code>src/</code>: Main Game Source Code.<ul> <li> <code>core/</code>: Engine logic (Game loop, Graphics, Physics, UI).</li> <li> <code>entities/</code>: Game Objects (Bulldozer, Gems, Map).</li> <li> <code>utils/</code>: Shared utilities (Math, Graphics).</li> </ul> </li> <li><code>pipeline/</code>: The Asset Factory (\"Source of Truth\").<ul> <li> <code>blender/</code>: Python scripts for geometry generation.</li> <li> <code>textures/</code>: Python scripts for procedural texture generation.</li> <li> <code>scripts/</code>: Node.js build and verification scripts.</li> </ul> </li> <li><code>tools/</code>: Developer Tools.<ul> <li> <code>viewer/</code>: The DAMP Asset Director (Web App).</li> <li> <code>physics-playground/</code>: Isolated physics testing environment.</li> </ul> </li> <li><code>assets/</code>: Source configuration for assets.<ul> <li> <code>configs/</code>: JSON configuration files for the pipeline.</li> </ul> </li> <li><code>docs/</code>: Project Documentation.</li> <li><code>dist/</code>: (Generated) Build artifacts, including compiled assets and the playable game.</li> </ul>"},{"location":"living/guide/PROJECT_STRUCTURE/#key-workflows","title":"Key Workflows","text":""},{"location":"living/guide/PROJECT_STRUCTURE/#setup","title":"Setup","text":"<p>Ensure you have <code>uv</code> and <code>go-task</code> installed (handled by <code>.julesrc</code> in dev container).</p>"},{"location":"living/guide/PROJECT_STRUCTURE/#commands","title":"Commands","text":"Run Build Command Description <code>task dev</code> Starts the main game server locally. <code>task damp:viewer</code> Starts the Asset Viewer tool. Command Description <code>task build:assets</code> Runs the full Blender pipeline to generate GLBs and textures. <code>task build:dist</code> Creates a production build in <code>dist/</code>. <code>task docs:build</code> Builds this documentation site."},{"location":"living/guide/game_design_principles/","title":"Game Design Principles","text":"<p>Philosophy</p> <p>This document captures the core design philosophies for this project. When making decisions, refer to these principles to ensure the game \"feels\" right.</p>"},{"location":"living/guide/game_design_principles/#1-the-juice-game-feel","title":"1. The \"Juice\" (Game Feel)","text":"<p>\"Juice\" is the tactile feedback that makes interaction satisfying. *   Everything Reacts: When an object is touched, collected, or bought, it must react. (Particles, floating text, sound, scale bounce). *   Instant Feedback: Never delay the visual result of an action. If a gem is collected, it disappears this frame, even if the logic takes longer. *   Exaggeration: Realism is secondary to clarity. A 10% upgrade should look like a 10% upgrade, but a Level 10 bulldozer should look absurdly powerful compared to Level 1.</p>"},{"location":"living/guide/game_design_principles/#2-progression-pacing","title":"2. Progression &amp; Pacing","text":"<ul> <li>The Power Fantasy: The player starts weak and slow. The goal is to make them feel unstoppable by the end.</li> <li>Micro-Goals: The player should always have a goal reachable within 1-2 minutes (e.g., \"Buy next Engine level\").</li> <li>Macro-Goals: The player needs a horizon goal (e.g., \"Unlock the Red Zone\").</li> <li>Friction vs. Flow:<ul> <li>Friction (Slow movement, walls) makes the Flow (Speed upgrades, breaking through) satisfying.</li> <li>Do not remove all friction too early.</li> </ul> </li> </ul>"},{"location":"living/guide/game_design_principles/#3-clarity-readability","title":"3. Clarity &amp; Readability","text":"<ul> <li>Form Follows Function: A \"Collector\" should look like it collects things (funnels, belts). A \"Shop\" should look like a place of transaction.</li> <li>Visual Hierarchy: The most important elements (The Player, The Gems) must contrast with the background.</li> <li>Numbers: Keep numbers readable. \"1.5k\" is better than \"1500\" in tight UI, but precise numbers feel more \"RPG-like\" in stats panels.</li> </ul>"},{"location":"living/guide/game_design_principles/#4-engineering-for-design","title":"4. Engineering for Design","text":"<ul> <li>Exposed Knobs: Design systems with \"Knobs\" (Constants, Configs) that can be tweaked without rewriting logic.</li> <li>Iterative Balance: Balance is never done. Build tools (like the Asset Viewer or Debug Consoles) that help us \"feel\" the values.</li> <li>Separation of Logic and Visuals: The physics simulation (Matter.js) is the \"Truth\", but the Visuals (Three.js) are the \"Experience\". It's okay to cheat visuals (e.g., floating coins) to make it look good.</li> </ul>"},{"location":"living/guide/game_design_principles/#5-next-steps-for-better-design","title":"5. Next Steps for \"Better\" Design","text":"<ul> <li>Sound: Currently missing. Sound is 50% of the \"Juice\".</li> <li>Save/Load: Progression is meaningless if lost on refresh.</li> <li>Victory Lap: After winning, give the player a \"Toy\" (e.g., infinite speed, sandbox mode) to enjoy their power.</li> </ul>"},{"location":"living/guide/progression_analysis/","title":"Progression Analysis (Current State)","text":"<p>Metadata</p> <ul> <li>Date: 2024-10-25</li> <li>Version: 1.1</li> <li>Scope: Current values for costs, entity stats, and economy.</li> </ul> <p>Context</p> <p>This document outlines the current mathematical models governing the game's progression, including upgrade costs, entity scaling, and economic availability.</p>"},{"location":"living/guide/progression_analysis/#1-economy-gems","title":"1. Economy (Gems)","text":"<p>The game world is divided into three zones. Gems are the sole source of currency.</p> Zone Gems Value Range Avg Value Zone Total (Approx) Unlock Condition 1 400 8 - 12 10 $4,000 Start 2 400 25 - 40 32.5 $13,000 50% of Zone 1 Collected 3 400 60 - 100 80 $32,000 50% of Zone 2 Collected Total 1200 ~$49,000 <ul> <li>Victory Condition: Collect all gems in the world.</li> <li>Gate Logic: \"Area Level\" controls physical gates.<ul> <li>Area Lvl 1 -&gt; 2 (Unlocks Zone 2): Automatically happens when Zone 1 is 50% clear.</li> <li>Area Lvl 2 -&gt; 3 (Unlocks Zone 3): Automatically happens when Zone 2 is 50% clear.</li> </ul> </li> </ul>"},{"location":"living/guide/progression_analysis/#2-upgrade-costs","title":"2. Upgrade Costs","text":"<p>All upgrades follow a simple exponential growth curve: <code>NewCost = floor(OldCost * 1.5)</code>.</p> Upgrade Base Cost Growth Cost @ Lvl 5 Cost @ Lvl 10 Engine 100 x1.5 506 3,844 Plow 100 x1.5 506 3,844 Collector 150 x1.5 759 5,766 <ul> <li>Area Unlock (Manual):<ul> <li>The <code>shop.js</code> code contains logic for purchasing \"Unlock Gate\", but <code>gem.js</code> also contains logic for automatic unlocking based on progress.</li> <li>There appears to be a dual-system (Purchase vs Auto). Currently, the \"Unlock Gate\" pad exists but might be redundant if auto-unlock triggers first.</li> <li>Manual Cost: 500 (Lvl 2), 2000 (Lvl 3).</li> </ul> </li> </ul>"},{"location":"living/guide/progression_analysis/#3-entity-scaling","title":"3. Entity Scaling","text":""},{"location":"living/guide/progression_analysis/#bulldozer-engine","title":"Bulldozer (Engine)","text":"<ul> <li>Density: Scales linearly (<code>0.002 + Level * 0.0001</code>) to prevent excessive mass growth.</li> <li>Force: Calculated dynamically as <code>Power * Throttle</code>, where Power scales with level (<code>0.012 * 1.25^Level</code>).</li> <li>Volume: Increases quadratically (<code>40 + 5*Level</code>).</li> <li>Resulting Physics:<ul> <li>Mass: Grows quadratically due to volume, but controlled by linear density.</li> <li>Acceleration: By tuning the Force scaling to 1.25x or higher, we ensure it outpaces the Mass growth, resulting in a net increase in acceleration per level.</li> <li>Correction: Previous exponential density scaling (1.5x) caused mass to outpace force. This has been refactored.</li> </ul> </li> </ul>"},{"location":"living/guide/progression_analysis/#plow","title":"Plow","text":"<ul> <li>Base Width: <code>45</code> units (Physically scaled x10 -&gt; 450px).</li> <li>Growth: <code>+5</code> units per level.</li> <li>Depth: <code>10</code> units (Constant).</li> <li>Effect: Level 10 plow is double the width of Level 1 (Base 45 + 45 = 90).</li> </ul>"},{"location":"living/guide/progression_analysis/#collector","title":"Collector","text":"<ul> <li>Base Body: Circle, Radius <code>30 + (Level * 5)</code> (Diameter <code>60 + 10*Lvl</code>).</li> <li>Belts (Lvl &gt; 1):<ul> <li>Length: <code>50 + (Level - 2) * 50</code> (Capped at 500).</li> <li>Width: <code>60 + floor((Level - 2) / 2) * 20</code>.</li> <li>Top Belt: Added at Level 4.</li> </ul> </li> <li>Effect: Significantly increases catchment area starting at Level 2.</li> </ul>"},{"location":"living/guide/progression_analysis/#4-analysis","title":"4. Analysis","text":"<ul> <li>Total Money Cap: With ~$49,000 total in the world, the player effectively hits a \"Soft Cap\" on upgrades around Level 12-13 for a single item, or Level 9-10 spread across all three.</li> <li>Pacing: The exponential cost curve means early upgrades are frequent, but late game upgrades become grindy.</li> <li>Physics Imbalance: The Engine upgrade logic is flawed. By scaling Density exponentially to make the dozer \"heavy\" (good for pushing piles of gems), we inadvertently made it too heavy for its own engine.</li> <li>Redundancy: The \"Buy Area\" shop pad conflicts with the \"Auto Unlock\" mechanic in <code>gem.js</code>.</li> </ul>"},{"location":"planning/roadmap/","title":"Roadmap","text":""},{"location":"planning/roadmap/#active-work","title":"Active Work","text":"<ul> <li> Scaling Rebalance: Rebalancing game economy and progression. (View Plan)</li> <li> Documentation Rewrite: Full audit and restructure of project documentation to reflect current state. (View Plan)</li> <li> UI &amp; Gameplay Polish: Replaced physical \"Money Mat\" with flying coin UI animation and fixed collector upgrade scaling. (View Plan)</li> </ul>"},{"location":"planning/roadmap/#backlog","title":"Backlog","text":"<ul> <li> Asset Pipeline Optimization: Further refinements to the Blender -&gt; GLB pipeline.</li> <li> Gameplay Features: Additional upgrades and levels.</li> <li> Mobile Optimization: Improve touch controls and performance on mobile devices.</li> </ul>"},{"location":"planning/task_scaling_rebalance/","title":"Task: Scaling Rebalance &amp; Progression Tuning","text":"<p> Metadata</p> <ul> <li>Status: In Progress</li> <li>Type: Rebalance / Feature</li> <li>Dependencies: <code>docs/living/guide/progression_analysis.md</code></li> </ul> <p> Context</p> <p>Refine the game's progression curve to ensure a satisfying \"Power Fantasy\" loop while maintaining challenge. Resolve the conflict between manual and automatic area unlocking.</p> <p> Plan</p> <ol> <li>Resolve Unlock Logic<ul> <li>Remove the \"Auto Unlock\" feature from <code>gem.js</code>.</li> <li>Keep the Zone Progress notification but change the reward to a large \"Bonus Cash\" drop.</li> </ul> </li> <li>Tune Economy (Inflation)<ul> <li>Increase Gem Values in Zone 3 (100-200 value).</li> </ul> </li> <li>Refactor Physics Scaling (Engine)<ul> <li>Make Density scaling linear.</li> <li>Switch to \"Power Rating\" based Force calculation: <code>Force = 0.012 * 1.25^Level</code>. This provides a stronger acceleration curve than the previous 1.2x.</li> </ul> </li> <li>Adjust Upgrade Curves (Plow &amp; Collector)<ul> <li>Plow: Increase width scaling to <code>+8</code> per level. Wings scale with level.</li> <li>Collector: Ensure Belts visual scaling matches physics scaling.</li> </ul> </li> <li>Cost Curve Smoothing<ul> <li>Change to <code>Cost = Base * (1.3 ^ (Level - 1))</code>.</li> </ul> </li> </ol> <p> Execution Log</p> <ul> <li> Physics Fix: Refactor density to linear, Force to Power-based model.</li> <li> Unlock Logic: Remove auto-unlock and update Shop logic.</li> <li> Economy: Tune Zone 3 gem values.</li> <li> Upgrades: Adjust plow width/wings and smoothing cost curves.</li> <li> Re-tuning: Increased engine power scaling to 1.25x to overcome quadratic mass growth.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/","title":"Current Plan: Refactoring &amp; Docs","text":"<p>Date: 2025-05-18 (Session Date)</p>"},{"location":"planning/archive/2025-05-18_refactoring/#overview","title":"Overview","text":"<p>We are solidifying the DAMP pipeline and improving project documentation infrastructure.</p>"},{"location":"planning/archive/2025-05-18_refactoring/#changes","title":"Changes","text":""},{"location":"planning/archive/2025-05-18_refactoring/#1-code-maintenance","title":"1. Code Maintenance","text":"<ul> <li>Consolidated <code>cb()</code> Utility: Moved the cache-busting function from scattered files to <code>src/utils/graphics-utils.js</code>.</li> <li>Blender Parenting: Refactored <code>pipeline/blender/bulldozer.py</code> to use object parenting instead of mesh joining. This ensures that individual components (Wheels, Cabin) retain their <code>damp_id</code> contract tags in the exported GLB.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/#2-documentation-system","title":"2. Documentation System","text":"<ul> <li>MkDocs: Setting up <code>mkdocs</code> with the <code>material</code> theme for a professional documentation site.</li> <li>Auto-Formatting: Integrating <code>mdformat</code> to keep documentation consistent.</li> <li>Deployment: Ensuring docs are built and published to <code>dist/docs</code> during PR previews.</li> </ul>"},{"location":"planning/archive/2025-05-18_refactoring/#next-steps","title":"Next Steps","text":"<ul> <li> Verify the new GLB structure in the Asset Viewer.</li> <li> Verify the documentation site build.</li> </ul>"},{"location":"planning/archive/2026-01-07_ui_gameplay_polish/","title":"Plan: UI &amp; Gameplay Polish","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2026-01-07</li> <li>Author: Jules (AI Agent)</li> </ul> <p> Context</p> <p>The project required several refinements to improve visual polish and fix gameplay bugs. Specifically: 1.  Money Mat: The physical \"mat\" and 3D coin piles were causing visual clutter and were deemed unnecessary. 2.  Coin Animation: A more engaging visual feedback for currency collection was requested, specifically animating \"flying coins\" to the UI counter. 3.  Collector Upgrade: The collector logic scaled exponentially, causing the entity to extend infinitely and clip through map walls at high levels.</p> <p> Plan</p> <ol> <li>Remove Money Mat: Delete <code>createCoinPile</code>, <code>updateCoinPile</code>, and related groups from <code>src/core/graphics.js</code>.</li> <li>UI Animation: Implement <code>spawnCoinDrop</code> using DOM elements (<code>.flying-coin</code>) and the Web Animations API to animate coins from world-space to the <code>#money</code> UI element.</li> <li>Collector Fix: Refactor <code>src/entities/collector.js</code> to use linear scaling (<code>50 + (level-2)*50</code>) and cap the length at 500 units.</li> <li>Verification: Add a Playwright script to verify the visual changes.</li> </ol> <p> Execution Log</p> <ul> <li> Cleanup: Removed <code>coinPileGroup</code> and related logic from <code>src/core/graphics.js</code>.</li> <li> Animation: Implemented DOM-based flying coin animation in <code>spawnCoinDrop</code>.</li> <li> Styling: Added <code>.flying-coin</code> class to <code>style.css</code>.</li> <li> Fix: Updated <code>src/entities/collector.js</code> to cap belt length and use linear growth.</li> <li> Verification: Verified via <code>verification/verify_changes.py</code> (flying coins detected).</li> </ul> <p> AI Summary</p> <p>The tasks were successfully completed. The removal of the 3D money pile reduces scene complexity, while the new flying coin animation provides clear, satisfying feedback for the player. The collector upgrade logic is now robust against map boundary clipping.</p>"},{"location":"planning/archive/doc_rewrite/","title":"Plan: Documentation Rewrite","text":"<p> Metadata</p> <ul> <li>Status: Completed</li> <li>Date: 2025-05-19</li> <li>Author: Jules (AI Agent)</li> </ul> <p> Context</p> <p>The project documentation was fragmented, out of date, and lacked a clear structure. The goal of this task was to perform a \"Full Rewrite\" to consolidate information, establish a clear hierarchy, and implement a maintainable roadmap structure. Additionally, we aimed to \"uplift\" the visual presentation using <code>mkdocs-material</code> features like admonitions and tabs.</p> <p> Plan</p> <ol> <li>Consolidate and Clean Up: Remove duplicate files and archive old plans.</li> <li>Restructure: Organize <code>docs/</code> into logical subdirectories (<code>architecture</code>, <code>troubleshooting</code>, <code>history</code>).</li> <li>Update Content: Rewrite key architectural docs (<code>DAMP.md</code>) to reflect the current \"Explicit Contract\" state.</li> <li>Enhance: Add <code>mkdocs-material</code> plugins and formatting.</li> <li>Tooling: Add a pre-commit script to enforce documentation formatting.</li> </ol> <p> Execution Log</p> <ul> <li> Restructuring: Moved files to <code>docs/architecture</code>, <code>docs/guide</code>, etc.</li> <li> Roadmap: Created <code>docs/planning/roadmap.md</code> and archived old plans.</li> <li> Rewrite: Completely rewrote <code>DAMP_MAINTAINABILITY.md</code> to remove outdated \"Proposed\" logic.</li> <li> Uplift: Updated <code>mkdocs.yml</code> with <code>awesome-pages</code>, <code>admonition</code>, and <code>pymdownx.emoji</code>.</li> <li> Tooling: Implemented <code>pipeline/scripts/format_docs.py</code> using <code>uvx</code> and <code>mdformat</code> (resolving dependency conflicts by removing <code>mdformat-admon</code>).</li> <li> Verification: Validated build via <code>task docs:build</code>.</li> </ul> <p> AI Summary</p> <p>The documentation ecosystem has been successfully migrated to a structured, maintainable format.</p> <p>Key Achievements:</p> <ul> <li>Architecture: The \"Four Pillars\" structure (Src, Pipeline, Tools, Assets) is now formally documented.</li> <li>Pipeline: The \"Explicit Contract\" model (using <code>damp_id</code>) is codified as the source of truth, replacing old speculative docs.</li> <li>Visuals: Documentation now uses consistent admonitions, tabs for commands, and icons for navigation.</li> <li>Workflow: A new <code>task docs:format</code> command ensures consistency going forward.</li> </ul> <p>Next Steps for Future Agents:</p> <ul> <li>Refer to <code>docs/living/architecture/DAMP.md</code> for architectural decisions.</li> <li>Use <code>docs/planning/roadmap.md</code> to track future work.</li> <li>Ensure all new docs pass <code>task docs:lint</code>.</li> </ul>"}]}