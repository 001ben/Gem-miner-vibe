{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation Index","text":""},{"location":"#active-documentation","title":"\ud83d\udfe2 Active Documentation","text":"<p>These documents reflect the current DAMP (Distributed Asset &amp; Material Pipeline) architecture.</p> <ul> <li>DAMP_MAINTAINABILITY.md - Start Here. The current architectural \"Bible\". Explains the \"Explicit Contract\" model, the Taskfile build system, and the maintainability roadmap.</li> <li>BLENDER_PIPELINE.md - Guide to creating new assets using Blender Python scripts.</li> <li>DAMP_PIPELINE_REVIEW.md - Context on the transition from \"Implicit\" to \"Explicit\" pipelines and technical design decisions.</li> <li>GRAPHICS_TROUBLESHOOTING.md - Reference for solving common rendering artifacts (Shadow Acne, etc.).</li> <li>COMMON_ERRORS.md - Solutions for build and runtime environment issues.</li> </ul>"},{"location":"#legacy-archived-archive","title":"\ud83d\udfe1 Legacy / Archived (<code>/archive</code>)","text":"<p>These documents are preserved for historical context but describe deprecated workflows (OpenSCAD, pre-GLTF).</p> <ul> <li><code>ASSET_PIPELINE.md</code> - The old OpenSCAD workflow.</li> <li><code>SCAD_VS_BLENDER.md</code> - Decision record comparing the two approaches.</li> <li><code>GRAPHICS_DESIGN.md</code> - Analysis of the legacy \"Programmer Art\" rendering system.</li> <li><code>BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL.md</code> - Early exploration of rendering frameworks.</li> </ul>"},{"location":"BLENDER_PIPELINE/","title":"Asset Generation: The \"Game Ready\" Pipeline (Blender + Python)","text":"<p>While OpenSCAD is excellent for \"Programmer CAD,\" it struggles with game-specific needs like UV Mapping and Topology. We have introduced a second pipeline option: Blender Python Scripting.</p> <p>This allows you to generate assets using Python code (keeping the \"Programmer\" workflow) while leveraging Blender's industry-standard tools for UV unwrapping and GLTF export.</p>"},{"location":"BLENDER_PIPELINE/#architecture","title":"Architecture","text":"<ol> <li>Source: Python scripts (<code>.py</code>) located in <code>assets/source/blender/</code>.</li> <li>Engine: Blender (headless mode).</li> <li>Compilation: <code>task assets:geometry</code> (via Taskfile) runs Blender to execute the script and export <code>.glb</code>.</li> <li>Result: Game-ready assets with UVs and Materials.</li> </ol>"},{"location":"BLENDER_PIPELINE/#how-to-use","title":"How to use","text":"<ol> <li>Create a python script in <code>assets/source/blender/my_asset.py</code>.</li> <li>Use the <code>bpy</code> library to generate geometry.</li> <li>Run <code>task build:assets</code>.</li> </ol>"},{"location":"BLENDER_PIPELINE/#example-blender-script","title":"Example Blender Script","text":"<pre><code>import bpy\n\n# Clear existing\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete()\n\n# Create Cube\nbpy.ops.mesh.primitive_cube_add(size=2)\nobj = bpy.context.object\n\n# Auto UV Unwrap\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_all(action='SELECT')\nbpy.ops.uv.smart_project()\nbpy.ops.object.mode_set(mode='OBJECT')\n\n# Export\nbpy.ops.export_scene.gltf(filepath=\"my_asset.glb\")\n</code></pre>"},{"location":"COMMON_ERRORS/","title":"Common Errors &amp; Troubleshooting","text":""},{"location":"COMMON_ERRORS/#asset-viewer","title":"Asset Viewer","text":""},{"location":"COMMON_ERRORS/#failed-to-load-resource-script-unknown-source","title":"<code>Failed to load resource: &lt;SCRIPT&gt; unknown source</code>","text":"<p>Symptoms:</p> <ul> <li>The asset viewer loads the UI but the 3D scene is empty.</li> <li>The console (or on-screen log) shows \"Failed to load resource\" pointing to the main module script.</li> <li>\"Three.js imported successfully\" is NOT logged.</li> </ul> <p>Cause: This error occurs when the browser cannot resolve one of the JavaScript modules imported by the viewer. Common reasons include:</p> <ol> <li>Incorrect Server Root: The web server was started from the <code>verification/</code> directory instead of the repository root. This makes <code>../js/</code> and <code>../node_modules/</code> inaccessible (404).</li> <li>Missing Dependencies: <code>npm install</code> has not been run, so <code>node_modules</code> is missing or incomplete.</li> <li>Deployment Path Issues: In a deployed environment (e.g., GitHub Pages), the relative paths to <code>js/</code> or <code>node_modules/</code> might be incorrect if the build script didn't rewrite them properly.</li> </ol> <p>Solution:</p> <ol> <li>Local Development:<ul> <li>Use the Taskfile commands to start the viewer from the correct root:     <pre><code># New React Viewer\ntask damp:viewer\n\n# Legacy Viewer\ntask viewer\n</code></pre></li> </ul> </li> <li>Deployment:<ul> <li>Check the <code>pr-preview.yml</code> workflow to ensure it copies source files to the <code>dist/</code> folder and rewrites paths (<code>sed</code>) in <code>index.html</code>.</li> </ul> </li> </ol>"},{"location":"COMMON_ERRORS/#failed-to-load-resource-bulldozer_componentsglb-404","title":"<code>Failed to load resource: ... bulldozer_components.glb</code> (404)","text":"<p>Cause: The 3D assets have not been built locally.</p> <p>Solution: Run the asset build task:</p> <pre><code>task build:assets\n</code></pre> <p>Note: The asset viewer handles this gracefully by logging a warning, but the model will not appear.</p>"},{"location":"COMMON_ERRORS/#graphics-glitches","title":"Graphics Glitches","text":""},{"location":"COMMON_ERRORS/#fan-like-vertical-tracks","title":"\"Fan-like\" Vertical Tracks","text":"<p>Cause: The track link mesh orientation in the GLB does not match the animation logic (Three.js <code>lookAt</code> expects Z-forward). Solution: Use the \"Track Adj\" controls in the Asset Viewer to set Z-Rotation to 270.</p>"},{"location":"COMMON_ERRORS/#flickering-vanishing-tracks","title":"Flickering / Vanishing Tracks","text":"<p>Cause: Gimbal lock when the track tangent aligns with the World Y-axis. Solution: Ensure the \"Up\" vector in the Asset Viewer is set to X (Axle).</p>"},{"location":"DAMP_MAINTAINABILITY/","title":"DAMP Pipeline: Maintainability &amp; Organization Roadmap","text":""},{"location":"DAMP_MAINTAINABILITY/#1-core-philosophy-explicit-implicit","title":"1. Core Philosophy: \"Explicit &gt; Implicit\"","text":"<p>The primary source of bugs in the current iteration is Implicit Logic\u2014guessing mesh names, assuming alignment offsets, and relying on runtime discovery to fix build-time naming genericisms. To improve maintainability, we must shift to a contract-based architecture.</p>"},{"location":"DAMP_MAINTAINABILITY/#the-contract-model","title":"The Contract Model:","text":"<ul> <li>Blender (Provider): Must explicitly tag meshes with a permanent <code>damp_id</code>.</li> <li>JSON (Contract): Must define properties using that <code>damp_id</code>.</li> <li>Renderer (Consumer): Must only look for <code>damp_id</code>, ignoring generic names like <code>Cube001</code>.</li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#2-structural-improvements","title":"2. Structural Improvements","text":""},{"location":"DAMP_MAINTAINABILITY/#a-centralized-resource-loader-assetmanagerjs","title":"A. Centralized Resource Loader (<code>AssetManager.js</code>)","text":"<p>Currently, cache-busting and fetching are spread across the viewer and renderer.</p> <ul> <li>Problem: Inconsistent caching leads to \"ghost bugs\" where code is new but assets are old.</li> <li>Solution: Create a singleton <code>AssetManager</code> that handles:<ul> <li>Centralized <code>cb()</code> (cache-busting) strategy.</li> <li>Global texture registry (to avoid redundant cloning vs sharing).</li> <li>Unified error reporting for missing assets.</li> </ul> </li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#b-standardized-component-lifecycle","title":"B. Standardized Component Lifecycle","text":"<p>The \"Discovery\" phase in the viewer currently fights with the Renderer's internal load.</p> <ul> <li>Current Lifecycle: Load GLB -&gt; Guess Materials -&gt; UI Scans Scene -&gt; UI Updates Materials -&gt; (Race Condition).</li> <li>Proposed Lifecycle:<ol> <li>Initialization: Renderer loads GLB and JSON.</li> <li>Mapping: Renderer maps meshes to config using <code>damp_id</code> custom properties.</li> <li>Registration: Renderer emits a structured <code>Manifest</code> of all tunable parts.</li> <li>UI Binding: Viewer simply iterates the <code>Manifest</code> to build controls.</li> </ol> </li> <li>Benefit: Eliminate race conditions and ensure the UI always reflects the internal state of the renderer.</li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#c-decoupled-assembly-logic","title":"C. Decoupled Assembly Logic","text":"<p>Alignment offsets (Vertical/Spread) are currently split between Blender scripts, hardcoded Renderer defaults, and UI state.</p> <ul> <li>Problem: Changing a value in one place requires manual synchronization in three others.</li> <li>Solution: Move all assembly offsets into the <code>config.json</code>. Blender should export at origin <code>(0,0,0)</code>, and the JSON should dictate where the tracks sit relative to the body.</li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#3-organization-checklist-for-maintainability","title":"3. Organization Checklist for Maintainability","text":""},{"location":"DAMP_MAINTAINABILITY/#data-organization","title":"Data Organization:","text":"<ul> <li>[ ] Standard Schema: Define a <code>damp-schema.json</code> to validate asset mappings.</li> <li>[ ] Asset Namespacing: Move generated textures from <code>assets/textures/</code> to <code>assets/generated/</code> to clearly distinguish them from hand-authored source art.</li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#code-organization","title":"Code Organization:","text":"<ul> <li>[ ] Base Class: Create a <code>BaseEntityRenderer</code> that handles the boilerplate (Three.js group management, <code>setPose</code>, <code>destroy</code>, generic <code>applyMaterial</code>).</li> <li>[ ] Shared Utilities: Move <code>cb()</code>, <code>getPointsFromMesh()</code>, and <code>enhanceMaterialWithTriplanar()</code> into a shared <code>js/utils/graphics-utils.js</code>.</li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#4-debugging-observability","title":"4. Debugging &amp; Observability","text":"<p>Non-obvious bugs thrive in silent failures.</p> <ul> <li>Action: Implement a \"Debug Overlay\" in the Asset Director that highlights the selected mesh in the 3D scene (e.g., using a wireframe helper or a bounding box).</li> <li>Action: Ensure every <code>[WARN]</code> and <code>[ERROR]</code> includes the specific component name and file path that failed.</li> </ul>"},{"location":"DAMP_MAINTAINABILITY/#5-phase-1-immediate-maintenance-actions","title":"5. Phase 1: Immediate Maintenance Actions","text":"<ol> <li>Refactor Blender Output: Update <code>bulldozer.py</code> to add custom properties to objects: <code>obj[\"damp_id\"] = \"chassis\"</code>.</li> <li>Standardize Utility Imports: Replace multiple <code>cb()</code> definitions with a single imported utility.</li> <li>Consolidate Offset Logic: Move the perfect offsets (<code>-0.53</code>, <code>0.15</code>) into the <code>bulldozer_mapping.json</code> under an <code>assembly</code> key.</li> </ol> <p>Updated: Thursday 18 December 2025 Focus: Long-term code health and developer ergonomics.</p>"},{"location":"DAMP_PIPELINE_REVIEW/","title":"DAMP Pipeline Review &amp; Design Commentary","text":""},{"location":"DAMP_PIPELINE_REVIEW/#1-architectural-overview","title":"1. Architectural Overview","text":"<p>The Distributed Asset &amp; Material Pipeline (DAMP) successfully bridges the gap between Programmatic CAD (Blender/Python) and Real-time Web Rendering (Three.js). It follows a \"Source-of-Truth\" model where geometry is generated on-demand, and a JSON configuration layer decouples the visual styling from the raw mesh data.</p>"},{"location":"DAMP_PIPELINE_REVIEW/#the-flow","title":"The Flow:","text":"<ol> <li>Geometry (<code>bulldozer.py</code>): Defines the \"bones\" and \"shell\" of the entity using Blender's Python API.</li> <li>Texture Gen (<code>bulldozer.py</code>): Captures procedural details into static PNGs to avoid expensive real-time procedural overhead.</li> <li>Orchestration (<code>build-assets.js</code>): Compiles raw assets into a <code>catalog.json</code> for the web runtime and ensures consistent directory structures.</li> <li>Configuration (<code>bulldozer_mapping.json</code>): Defines the \"skin\"\u2014mapping textures and material physics (roughness, metalness, transparency) to specific meshes.</li> <li>Runtime (<code>bulldozer_render.js</code>): Interprets the GLB + Config to assemble the final high-fidelity entity in the game engine.</li> </ol>"},{"location":"DAMP_PIPELINE_REVIEW/#2-design-commentary","title":"2. Design Commentary","text":""},{"location":"DAMP_PIPELINE_REVIEW/#strengths","title":"Strengths","text":"<ul> <li>WYSIWYG Development: The Asset Director (Viewer) allows for real-time material tuning that can be exported directly to the game's config files.</li> <li>Decoupled Logic: Geometry changes in Blender don't require code changes in the game engine, provided the naming conventions remain stable.</li> <li>Performance Optimization: By baking procedural textures into PNGs during the build step, client-side GPU load is kept low while maintaining high visual detail.</li> <li>Material Presets: The \"Preset\" system (e.g., Glass, Track) allows for high-fidelity Three.js materials to be defined in code while still being configurable via JSON.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#current-challenges-the-magic-mapping","title":"Current Challenges (The \"Magic\" Mapping)","text":"<p>The most brittle part of the current design is the Generic Mesh Mapping.</p> <ul> <li>Issue: When Blender joins meshes, it creates names like <code>Cube001</code>, <code>Cube001_1</code>. The renderer has to \"guess\" that <code>Cube001_1</code> is a wheel based on material or generic string matches.</li> <li>Risk: Changes in Blender's joining order could swap these names, breaking the texture mapping in the game.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#3-technical-review-cleanup","title":"3. Technical Review &amp; Cleanup","text":""},{"location":"DAMP_PIPELINE_REVIEW/#assetssourceblenderbulldozerpy","title":"<code>assets/source/blender/bulldozer.py</code>","text":"<ul> <li>Review: Highly functional script. Current logic joins components (Cabin/Body) into a single mesh for simplicity.</li> <li>Suggestion: Transition to Parenting instead of <code>bpy.ops.object.join()</code>. Keeping components as separate objects in the GLB allows the renderer to find them directly by name without complex mapping logic.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#jsentitiesbulldozer_renderjs","title":"<code>js/entities/bulldozer_render.js</code>","text":"<ul> <li>Review: The <code>applyMaterial</code> logic currently performs heavy string matching to \"fix\" generic Blender export names.</li> <li>Cleanup: Standardize the <code>cb()</code> (cache-busting) utility across the project to reduce code duplication.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#viewersrcmainjs","title":"<code>viewer/src/main.js</code>","text":"<ul> <li>Review: The UI \"Discovery\" logic is clever but can be prone to race conditions with the renderer's initial load.</li> <li>Cleanup: Centralize component discovery within the <code>BulldozerRenderer</code> itself.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#4-proposed-improvements-roadmap","title":"4. Proposed Improvements (Roadmap)","text":""},{"location":"DAMP_PIPELINE_REVIEW/#phase-1-explicit-component-tagging-high-priority","title":"Phase 1: Explicit Component Tagging (High Priority)","text":"<p>Instead of matching strings like <code>\"Cube\"</code>, we should use Blender Custom Properties.</p> <ul> <li>Blender Python: <code>obj[\"damp_id\"] = \"Chassis\"</code></li> <li>Three.js Runtime: The GLTF loader preserves these in <code>mesh.userData.damp_id</code>.</li> <li>Result: 100% reliable mapping regardless of mesh joining or renaming.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#phase-2-unified-material-schema","title":"Phase 2: Unified Material Schema","text":"<p>Formalize the mapping JSON into a generic schema that supports:</p> <ul> <li><code>emissive</code> properties for glowing lights.</li> <li><code>normalMap</code> support for surface bump details.</li> <li><code>envMapIntensity</code> for more realistic glass reflections.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#phase-3-build-pipeline-hardening","title":"Phase 3: Build Pipeline Hardening","text":"<ul> <li>Schema Validation: Validate JSON configs against a schema during the build step to catch typos before runtime.</li> <li>Automated Thumbnails: Integrate a headless browser step to generate preview thumbnails for the <code>catalog.json</code>.</li> </ul>"},{"location":"DAMP_PIPELINE_REVIEW/#5-immediate-cleanup-checklist","title":"5. Immediate Cleanup Checklist","text":"<ul> <li>[ ] Consolidate Utilities: Move <code>cb()</code> cache-busting to a shared utility file.</li> <li>[ ] Blender Refactor: Update <code>bulldozer.py</code> to use parenting instead of joining for critical components.</li> <li>[ ] Remove Legacy Artifacts: Delete <code>existing_pipeline_files.txt</code> and unused <code>/verification</code> scripts.</li> <li>[ ] Standardize Interfaces: Ensure all renderers use the same <code>setPose(position, angle)</code> interface.</li> </ul> <p>Review Date: Thursday 18 December 2025</p>"},{"location":"GEMINI/","title":"Gemini Session Summary: DAMP Pipeline Evolution","text":"<p>This document tracks the key technical findings, architectural decisions, and critical \"NO\" moments (course corrections) during the development of the Distributed Asset &amp; Material Pipeline (DAMP).</p>"},{"location":"GEMINI/#the-core-achievement-the-explicit-contract","title":"\ud83d\ude80 The Core Achievement: The Explicit Contract","text":"<p>We successfully transitioned from an Implicit Pipeline (guessing mesh names like <code>Cube001</code>) to an Explicit Contract Model.</p> <ul> <li>Blender explicitly tags materials and objects with <code>damp_id</code>.</li> <li>JSON defines properties using those IDs.</li> <li>Renderer strictly enforces the contract (ID or Magenta Error).</li> </ul>"},{"location":"GEMINI/#key-technical-findings","title":"\ud83d\udee0 Key Technical Findings","text":""},{"location":"GEMINI/#1-parenting-joining","title":"1. Parenting &gt; Joining","text":"<ul> <li>Discovery: <code>bpy.ops.object.join()</code> in Blender destroys Object-level metadata and forces Three.js to split primitives at runtime, causing race conditions.</li> <li>Solution: Use Parenting. It preserves the logical hierarchy, keeps unique names/IDs intact, and allows for independent material tuning without complex \"heuristic\" code.</li> </ul>"},{"location":"GEMINI/#2-material-level-tagging","title":"2. Material-Level Tagging","text":"<ul> <li>Discovery: Custom properties on Materials are more resilient than on Objects. Even if geometry is merged, Three.js preserves material slots.</li> <li>Impact: Tagging materials directly (<code>MAT_Glass[\"damp_id\"] = \"cabin\"</code>) eliminated 50+ lines of brittle string-matching code in the renderer.</li> </ul>"},{"location":"GEMINI/#4-the-four-pillars-layout","title":"4. The \"Four Pillars\" Layout","text":"<ul> <li>Discovery: Keeping source, build tools, and distribution assets in a flat or overlapping structure leads to deployment risks and high cognitive load.</li> <li>Solution: Standardize on a Domain-Split structure: <code>src/</code> (App), <code>pipeline/</code> (Factory), <code>tools/</code> (DX), and <code>assets/</code> (Output). This isolates the \"Source of Truth\" from the \"Distribution Artifacts.\"</li> </ul>"},{"location":"GEMINI/#5-explicit-relative-paths-bare-specifiers","title":"5. Explicit Relative Paths &gt; Bare Specifiers","text":"<ul> <li>Discovery: Relying on <code>importmap</code> for internal project modules (like <code>core/</code>) makes the codebase brittle and harder to debug in standard environments without custom server configs.</li> <li>Solution: Use standard relative paths (<code>./</code>, <code>../</code>) for all internal modules. Save the <code>importmap</code> for external CDN-hosted dependencies (Three.js, React).</li> </ul>"},{"location":"GEMINI/#the-no-wall-critical-corrections","title":"\ud83d\uded1 The \"NO\" Wall: Critical Corrections","text":"<p>Significant moments where the user rejected a path, leading to a better architecture.</p> <ol> <li>NO to Local Libs: I initially tried to bundle Three.js locally in the viewer.<ul> <li>Correction: \"We switched to unpkg.\"</li> <li>Lesson: Keep the repo lean; use CDNs for standardized dependencies.</li> </ul> </li> <li>NO to \"One-Size-Fits-All\" Texturing: I initially applied one texture to the whole GLB.<ul> <li>Correction: \"Our actual bulldozer uses different textures per component.\"</li> <li>Lesson: The pipeline must support granular, component-level material mapping.</li> </ul> </li> <li>NO to Manual Scaling: I tried to fix alignment by manually setting scales/positions in JS.<ul> <li>Correction: This resulted in \"tiny bodies and giant tracks.\"</li> <li>Lesson: Bake transforms in the source (Blender). Vertices should be normalized at <code>(1,1,1)</code> before export.</li> </ul> </li> <li>NO to Heuristic Fallbacks: I added <code>if (name.includes(\"Cube\"))</code> to handle Blender's generic names.<ul> <li>Correction: \"Don't use fallbacks at all. Use IDs or error.\"</li> <li>Lesson: Reliability comes from explicit contracts, not clever guessing.</li> </ul> </li> <li>NO to Lazy Refactoring: I used <code>// ... logic here</code> placeholders in a file write.<ul> <li>Correction: \"Please don't use '... this logic' when making edit changes.\"</li> <li>Lesson: Always provide complete, functional source code.</li> </ul> </li> <li>NO to Internal Import Maps: I tried to map <code>core/</code> and <code>entities/</code> via <code>importmap</code> to \"fix\" the structure split.<ul> <li>Correction: \"Let's whack a mole the errors independently.\"</li> <li>Lesson: Don't mask path issues with specifier mappings; fix the source imports to use standard relative paths.</li> </ul> </li> <li>NO to \"Summary First\" Workflow: I summarized changes multiple times before actually calling the tool to apply them.<ul> <li>Correction: \"Apply changes to the file and THEN summarise your changes.\"</li> <li>Lesson: The tool call is the primary action; the text output is the confirmation of that action.</li> </ul> </li> </ol>"},{"location":"GEMINI/#maintainability-checklist","title":"\ud83c\udfd7 Maintainability Checklist","text":"<ul> <li>[x] Modular Build: 5-step process orchestrated by Taskfile.</li> <li>[x] Asset Isolation: Textures and models separated from core game logic.</li> <li>[x] Clean Pillar Split: Source, Pipeline, Tools, and Assets isolated in the filesystem.</li> <li>[x] Standard Imports: Pure relative module resolution without specifier hacks.</li> <li>[x] Verification: <code>task build:verify</code> provides a raw look at the GLB \"Contract\" before it hits the web.</li> <li>[x] Zero-Cache: Dynamic import maps and server headers ensure the latest code is always live.</li> </ul> <p>Session Date: Thursday 18 December 2025</p>"},{"location":"GRAPHICS_TROUBLESHOOTING/","title":"Graphics Troubleshooting: The \"Striped Shadow\" Artifact","text":""},{"location":"GRAPHICS_TROUBLESHOOTING/#the-issue","title":"The Issue","text":"<p>In 3D rendering, you may observe weird, striped shadow patterns across surfaces that look like texture glitches or blinds. This is often described as \"Shadow Acne\" or \"Self-Shadowing Artifacts.\"</p>"},{"location":"GRAPHICS_TROUBLESHOOTING/#the-cause","title":"The Cause","text":"<p>This is a fundamental limitation of Shadow Mapping.</p> <ol> <li>Depth Map Resolution: The light source renders the scene depth to a texture (the Shadow Map). This texture has limited resolution (e.g., 1024x1024 pixels).</li> <li>Quantization: When checking if a pixel on the screen is in shadow, the engine compares the pixel's depth to the value stored in the shadow map.</li> <li>The Glitch: Due to limited precision (quantization) and the angle of the light, a flat surface might calculate its depth as slightly behind the value in the shadow map for some pixels and in front for others. This causes the surface to cast a shadow on itself in a striped pattern.</li> </ol>"},{"location":"GRAPHICS_TROUBLESHOOTING/#the-fix","title":"The Fix","text":"<p>We need to tune the Shadow Bias.</p>"},{"location":"GRAPHICS_TROUBLESHOOTING/#1-bias-offset","title":"1. Bias (Offset)","text":"<p>This pushes the shadow slightly deeper/away from the light.</p> <ul> <li>Too Low: Acne remains.</li> <li>Too High: \"Peter Panning\" (shadows detach from the object).</li> </ul>"},{"location":"GRAPHICS_TROUBLESHOOTING/#2-normal-bias","title":"2. Normal Bias","text":"<p>This pushes the shadow lookup coordinate along the surface normal. This is very effective for curved or low-poly geometry (like our programmer art).</p>"},{"location":"GRAPHICS_TROUBLESHOOTING/#implementation-in-threejs","title":"Implementation in Three.js","text":"<pre><code>const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);\ndirLight.castShadow = true;\n\n// The Fix:\ndirLight.shadow.bias = -0.0005;      // Slight offset to remove acne\ndirLight.shadow.normalBias = 0.05;   // Pushes shadow based on surface angle\n</code></pre> <p>We have applied this fix to <code>asset_viewer.html</code>.</p>"},{"location":"PROJECT_STRUCTURE/","title":"Project Structure","text":"<p>Last Updated: Thursday 18 December 2025 Base Commit: 986e814b021c576336543506215aa7c4af29b5bd</p> <p>The project follows a \"Modern Standard\" structure to separate source code, build pipelines, and developer tools.</p>"},{"location":"PROJECT_STRUCTURE/#directory-layout","title":"Directory Layout","text":"<ul> <li><code>src/</code>: Main Game Source Code.<ul> <li><code>core/</code>: Engine logic (Game loop, Graphics, Physics, UI).</li> <li><code>entities/</code>: Game Objects (Bulldozer, Gems, Map).</li> </ul> </li> <li><code>pipeline/</code>: The Asset Factory (\"Source of Truth\").<ul> <li><code>blender/</code>: Python scripts for geometry generation.</li> <li><code>textures/</code>: Python scripts for procedural texture generation.</li> <li><code>scripts/</code>: Node.js build and verification scripts.</li> </ul> </li> <li><code>tools/</code>: Developer Tools.<ul> <li><code>viewer/</code>: The DAMP Asset Director (React App).</li> </ul> </li> <li><code>assets/</code>: Compiled/Distribution Assets (Output Only).<ul> <li><code>models/</code>: Generated <code>.glb</code> files.</li> <li><code>textures/</code>: Generated <code>.png</code> files.</li> <li><code>configs/</code>: JSON configuration files.</li> </ul> </li> <li><code>docs/</code>: Project Documentation.</li> </ul>"},{"location":"PROJECT_STRUCTURE/#key-workflows","title":"Key Workflows","text":"<ul> <li>Game Logic: Edit files in <code>src/</code>.</li> <li>Asset Logic: Edit files in <code>pipeline/</code>.</li> <li>Build Assets: Run <code>task build:assets</code>.</li> <li>Run Game: Run <code>task dev</code>.</li> <li>Run Asset Director: Run <code>task damp:viewer</code>.</li> </ul>"},{"location":"archive/ASSET_PIPELINE/","title":"Asset Pipeline &amp; Material Challenges","text":""},{"location":"archive/ASSET_PIPELINE/#current-architecture","title":"Current Architecture","text":"<p>Our \"Programmer CAD\" pipeline currently operates as follows:</p> <ol> <li>Source: Parametric geometry defined in OpenSCAD (<code>.scad</code>).</li> <li>Compilation: OpenSCAD CLI exports the geometry to ASCII STL.</li> <li>Conversion: A custom script (<code>stl2obj.js</code>) converts STL to OBJ.</li> <li>Packaging: <code>obj2gltf</code> converts OBJ to binary GLTF (<code>.glb</code>).</li> </ol>"},{"location":"archive/ASSET_PIPELINE/#implemented-strategy-component-based-assembly","title":"Implemented Strategy: Component-Based Assembly","text":"<p>To solve the \"monolithic mesh\" color limitation of STL, we have adopted a Component-Based Assembly strategy.</p> <ul> <li>Workflow:<ul> <li>Instead of one <code>bulldozer.scad</code>, we maintain separate source files:<ul> <li><code>bulldozer_body.scad</code></li> <li><code>bulldozer_tracks.scad</code></li> <li><code>bulldozer_cabin.scad</code></li> </ul> </li> <li>The build pipeline (<code>npm run build:assets</code>) compiles these individually into <code>.glb</code> files.</li> </ul> </li> <li>Runtime Assembly:<ul> <li>The game engine (Three.js) loads these separate assets.</li> <li>They are added to a single <code>THREE.Group</code> container.</li> <li>Colors/Materials: Because each part is a distinct mesh, we can assign different materials to them programmatically (e.g., <code>bodyMesh.material = yellowMaterial</code>, <code>tracksMesh.material = darkMaterial</code>).</li> </ul> </li> </ul>"},{"location":"archive/ASSET_PIPELINE/#future-roadmap-advanced-visuals-best-practices","title":"Future Roadmap: Advanced Visuals &amp; Best Practices","text":"<p>As we look to move beyond simple solid colors, here are the challenges and best practices for a \"Programmer CAD\" (Code-first) workflow vs. a traditional Artist workflow.</p>"},{"location":"archive/ASSET_PIPELINE/#1-textures-surface-detail","title":"1. Textures &amp; Surface Detail","text":"<p>The Challenge: Standard 3D texturing relies on UV Mapping\u2014unwrapping a 3D object onto a 2D plane so an image can be painted on it. OpenSCAD / CSG (Constructive Solid Geometry) tools do not generate UV maps automatically, and \"unwrapping\" a procedurally generated mesh manually defeats the purpose of an automated pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Triplanar Mapping: Instead of using UVs, use a special shader (or Three.js node material) that projects textures onto the object from the Top, Front, and Side (X, Y, Z axes). This allows you to apply \"Dirt\", \"Rust\", or \"Scratches\" textures to any shape without manual work.</li> <li>Matcaps (Material Capture): Use <code>THREE.MeshMatcapMaterial</code>. This uses a spherical reference image to fake complex lighting and reflection (e.g., chrome, shiny car paint) cheaply. It looks great and requires no UVs.</li> <li>Decals: For specific details (like a \"Hazard Stripe\" or a Logo), use a separate floating mesh or a \"Decal\" geometry placed slightly above the surface, rather than trying to texture the main body.</li> </ul>"},{"location":"archive/ASSET_PIPELINE/#2-animations","title":"2. Animations","text":"<p>The Challenge: Traditional game assets use \"Skinned Meshes\" (bones/skeletons) to deform geometry (e.g., a character bending their arm). OpenSCAD exports static rigid meshes. We cannot easily add \"bones\" to an STL file in this pipeline.</p> <p>Best Practice for Programmer CAD:</p> <ul> <li>Hierarchical / Rigid Body Animation: This is what we already support with the Component-Based Assembly.<ul> <li>Example: To animate the plow moving up and down, we do not bend the metal. We verify the <code>plow.glb</code> is its own object, and in the game code, we change its <code>position.y</code> or <code>rotation.x</code>.</li> <li>Example: To animate tracks, we don't deform the rubber. We scroll the texture on the tracks (UV offset animation) or rotate the wheels if they are separate parts.</li> </ul> </li> <li>Code-Driven Motion: All animation should be driven by game state (physics, input), not pre-baked animation clips (like an <code>.fbx</code> file might have). This gives the \"programmer\" ultimate control.</li> </ul>"},{"location":"archive/ASSET_PIPELINE/#summary-of-programmer-art-stack","title":"Summary of \"Programmer Art\" Stack","text":"Feature Traditional Workflow (Blender/Maya) Our Workflow (OpenSCAD/Three.js) Geometry Hand-modeled polygons Code-defined primitives (CSG) Colors Texture Maps / Vertex Paint Separate Parts / Runtime Materials Textures Manual UV Unwrapping Triplanar Mapping / Matcaps Animation Skeletal Rigging / Keyframes Hierarchical Code Manipulation <p>Next Steps Recommendation:</p> <ol> <li>Stick to solid colors for now to keep the style clean (e.g., \"Low Poly\" aesthetic).</li> <li>If detail is needed, explore Triplanar Mapping shaders to add noise/grit without needing asset changes.</li> <li>For the plow animation, ensure the plow is a separate asset from the body so it can be moved independently in code.</li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/","title":"Tutorial: The Bulldozer Renderer","text":""},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#1-the-high-level-goal","title":"1. The High-Level Goal","text":"<p>This file is responsible for:</p> <ol> <li>Loading the 3D model of the bulldozer.</li> <li>Painting it (creating textures via code, so no image files are needed).</li> <li>Animating the tank tracks so they look like they are rolling.</li> <li>Syncing the visual position with the physics body (Matter.js).</li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#2-generating-textures-procedurally","title":"2. Generating Textures \"Procedurally\"","text":"<p>Instead of loading JPG or PNG images (which takes time and bandwidth), this code \"draws\" its own textures using a virtual HTML Canvas.</p> <p>Function: <code>createProceduralTexture(type)</code></p> <ul> <li>How it works: It creates a hidden <code>&lt;canvas&gt;</code> element in memory, gets a 2D drawing context (<code>ctx</code>), and draws shapes.</li> <li>The \"Tracks\" Texture: It draws a dark background and then loops to draw chevron/V-shapes. This creates the tread pattern.</li> <li>The \"Body\" Texture: It draws a yellow square, then scatters random noise (dots) and rust spots to make it look like weathered metal.</li> <li>Three.js Conversion: Finally, <code>new THREE.CanvasTexture(canvas)</code> turns that drawing into something the 3D engine can wrap around a shape.</li> </ul> <pre><code>// Example logic simplified:\nif (type === 'tracks') {\n    ctx.fillStyle = '#333';\n    // Draw zig-zag lines for treads...\n}\nreturn new THREE.CanvasTexture(canvas);\n</code></pre>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#3-the-shader-magic-advanced","title":"3. The Shader Magic (Advanced)","text":"<p>Standard 3D models need \"UV Maps\" (instructions on how to wrap a 2D image around a 3D object). This file uses a clever trick called Triplanar Mapping to avoid needing perfect UVs.</p> <p>Function: <code>enhanceMaterialWithTriplanar(...)</code></p> <ul> <li>What is a Shader? A shader is a small program that runs on your Graphics Card (GPU) to decide the color of every single pixel.</li> <li>The Trick: It intercepts the standard Three.js material code (<code>onBeforeCompile</code>) and injects custom logic.</li> <li>Triplanar Logic: Instead of stretching a texture, it projects the texture from three directions (Top, Side, Front) and blends them together.</li> <li>Scrolling: For the tracks, it adds a <code>uTime</code> variable to slide the texture coordinates, making the treads look like they are moving without actually moving the geometry.</li> </ul>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#4-the-main-class-bulldozerrenderer","title":"4. The Main Class: <code>BulldozerRenderer</code>","text":""},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-constructor","title":"The Constructor","text":"<p>When <code>new BulldozerRenderer(scene)</code> is called:</p> <ol> <li>It creates a <code>THREE.Group</code>. Think of this as an invisible box that will hold all the bulldozer parts (body, glass, tracks).</li> <li>It creates a <code>GLTFLoader</code>. This is the tool that knows how to read <code>.glb</code> (3D model) files.</li> <li>It prepares empty lists (<code>animatedInstances</code>) to track things that need to move every frame.</li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-loadurl-method","title":"The <code>load(url)</code> method","text":"<p>This is the heavy lifter. It fetches the file and organizes the parts.</p> <ol> <li>Finding Parts: It loops through every object in the 3D file:<ul> <li>If the name contains \"Bulldozer_Body\", it keeps it as the chassis.</li> <li>If the name contains \"Asset_TrackLink\", it keeps track of track link to load.</li> <li>If the name contains \"Asset_TrackPath\", it reads the mathematical points to know the shape of the tracks (oval-ish).</li> </ul> </li> <li>Applying Materials: It creates the shiny glass material and the rough metal material (using the procedural textures from step 2).</li> <li>Building Tracks (InstancedMesh):<ul> <li>Instead of creating 50 separate 3D objects for the track links (which is slow), it uses <code>InstancedMesh</code>.</li> <li>This tells the GPU: \"Draw this one shape 50 times at these 50 different positions.\" It's a huge performance optimization.</li> <li>It uses <code>THREE.CatmullRomCurve3</code> to calculate a smooth path along the points found in the file.</li> </ul> </li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-setposeposition-angle-method","title":"The <code>setPose(position, angle)</code> method","text":"<p>This is the bridge between the Physics world (Matter.js) and the Visual world (Three.js).</p> <ul> <li>Matter.js (2D) calculates where the box is.</li> <li>Three.js (3D) needs to know where to draw it.</li> <li>This function copies the X/Y from physics to X/Z in 3D (since Y is \"up\" in 3D) and applies the rotation.</li> </ul> <pre><code>setPose(position, angle) {\n    this.group.position.set(position.x, 0, position.y); // Map 2D -&gt; 3D\n    this.group.rotation.y = -angle; // Rotate the model\n}\n</code></pre>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#the-updatedelta-method","title":"The <code>update(delta)</code> method","text":"<p>This runs 60 times a second (the game loop).</p> <ol> <li>Shader Time: It increases the <code>uTime</code> value so the track textures keep scrolling.</li> <li>Track Movement: It calculates the position of every single track link along the curve.<ul> <li><code>track.curve.getPointAt(t)</code>: \"Where is the link at 50% along the curve?\"</li> <li><code>track.curve.getTangentAt(t)</code>: \"Which way should it face?\"</li> <li>It updates the matrix (position+rotation) for all 50 track links instantly.</li> </ul> </li> </ol>"},{"location":"archive/BULLDOZER_RENDER_FRAMEWORKS_TUTORIAL/#summary","title":"Summary","text":"<ul> <li><code>bulldozer.js</code> is the \"Brain\" (Physics, Collision).</li> <li><code>bulldozer_render.js</code> is the \"Costume\" (Graphics).</li> <li>It generates its own \"fabric\" (textures) via code.</li> <li>It uses a \"Green Screen\" trick (Shaders) to animate the texture scrolling.</li> <li>It listens to the \"Brain\" every frame via <code>setPose</code> to know where to stand.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/","title":"Graphics System Design &amp; Analysis","text":""},{"location":"archive/GRAPHICS_DESIGN/#current-implementation","title":"Current Implementation","text":"<p>The current graphics implementation relies on a \"Programmer Art\" approach where 3D visuals are generated procedurally at runtime using Three.js primitives (<code>BoxGeometry</code>, <code>TorusGeometry</code>, <code>IcosahedronGeometry</code>).</p>"},{"location":"archive/GRAPHICS_DESIGN/#architecture","title":"Architecture","text":"<ul> <li>State Synchronization: The <code>updateGraphics()</code> loop iterates through all Matter.js physics bodies every frame.</li> <li>1:1 Mapping: Each physics body part (including compound body parts) creates and manages its own independent Three.js mesh.</li> <li>Procedural Generation: Visuals like the Bulldozer, Plow, and Collector are constructed by combining simple geometric shapes in code. Texture atlases or external models are not used.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#deviation-from-standard-practices","title":"Deviation from Standard Practices","text":"<p>Industry-standard web game development (using engines like Three.js, Babylon, or PlayCanvas) typically follows different patterns:</p> <ol> <li> <p>Asset-Based Workflow:</p> <ul> <li>Standard: Artists create models in tools like Blender/Maya/3ds Max and export them as <code>GLTF</code>/<code>GLB</code> files. These assets contain optimized geometry, UV maps, materials, and animations.</li> <li>Current: Geometry is hard-coded. Adjusting the \"look\" (e.g., curving a plow) requires complex trigonometric math and geometry manipulation in code rather than moving vertices in an editor.</li> </ul> </li> <li> <p>Scene Graph Hierarchy:</p> <ul> <li>Standard: A single visual root object represents a game entity (e.g., a Tank). Physics bodies update the root's transform, and child nodes (turret, wheels) are animated relative to that root.</li> <li>Current: Every physics sub-part (chassis, wheel, plow) drives its own mesh directly. This ensures tight physics matching but makes complex visual articulation (like suspension or smooth interpolation) harder to implement.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Standard: Use InstancedMesh for identical objects (like Gems). This allows rendering thousands of items with a single draw call.</li> <li>Current: Each Gem is a separate <code>Mesh</code> object. While Three.js handles frustum culling, the CPU overhead of updating thousands of individual scene graph nodes every frame limits the maximum gem density.</li> </ul> </li> </ol>"},{"location":"archive/GRAPHICS_DESIGN/#opportunities-for-improvement","title":"Opportunities for Improvement","text":""},{"location":"archive/GRAPHICS_DESIGN/#1-asset-pipeline-integration","title":"1. Asset Pipeline Integration","text":"<p>Moving to a GLTF loader workflow would immediately improve visual fidelity.</p> <ul> <li>Action: Create a <code>AssetManager</code> class to load <code>.glb</code> files.</li> <li>Benefit: \"Real\" modeled plows with proper curves, metallic textures, and baked ambient occlusion.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#2-instanced-rendering-for-gems","title":"2. Instanced Rendering for Gems","text":"<p>The \"Gem Fields\" concept requires high object counts.</p> <ul> <li>Action: Replace individual <code>IcosahedronGeometry</code> meshes with a single <code>THREE.InstancedMesh</code> managed by a specialized <code>GemRenderer</code> system.</li> <li>Benefit: Could easily support 10,000+ gems at 60fps, allowing for massive \"ocean of gems\" gameplay.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#3-decoupled-rendering-state","title":"3. Decoupled Rendering State","text":"<p>Currently, visuals snap to physics state.</p> <ul> <li>Action: Implement a state interpolation buffer. Render at screen refresh rate (e.g., 144Hz) while physics runs at fixed steps (60Hz), interpolating positions <code>(prev * (1-alpha) + curr * alpha)</code>.</li> <li>Benefit: Eliminates micro-stutter and provides buttery smooth motion, even if physics frames drop.</li> </ul>"},{"location":"archive/GRAPHICS_DESIGN/#4-shader-effects","title":"4. Shader Effects","text":"<ul> <li>Action: Replace standard materials with custom ShaderMaterials for effects like \"Glow\" on high-value gems, \"Heat distortion\" behind the engine, or dynamic tracks that fade using a fragment shader time uniform instead of transparency updates.</li> </ul>"},{"location":"archive/SCAD_VS_BLENDER/","title":"Asset Pipeline: OpenSCAD vs. Blender","text":"<p>We originally explored two different pipelines for generating 3D game assets. We have decided to standardize on the Blender pipeline. This document summarizes the differences, benefits, and reasons for this decision.</p>"},{"location":"archive/SCAD_VS_BLENDER/#1-the-openscad-pipeline-programmers-cad","title":"1. The OpenSCAD Pipeline (\"Programmer's CAD\")","text":"<p>Approach:</p> <ul> <li>Define geometry using Constructive Solid Geometry (CSG) in <code>.scad</code> files.</li> <li>Compile to STL -&gt; OBJ -&gt; GLTF using a chain of tools (<code>openscad</code>, <code>obj2gltf</code>).</li> <li>Procedural textures generated at runtime in the client.</li> </ul> <p>Code Snippet (<code>bulldozer_body.scad</code>):</p> <pre><code>// Parametric definition\nbody_width = 12;\nbody_length = 16;\nbody_height = 5;\n\n// CSG Operations\ntranslate([-body_width/2, -body_length/2, 4/2])\n    cube([body_width, body_length, body_height]);\n</code></pre> <p>Pros:</p> <ul> <li>Parametric: Easy to adjust dimensions via variables.</li> <li>Git-Friendly: Source files are pure text.</li> <li>Precise: Exact mathematical alignment.</li> </ul> <p>Cons:</p> <ul> <li>Limited Export: OpenSCAD exports raw geometry (STL) without UVs, Materials, or scene hierarchy.</li> <li>Rendering Issues: The generated meshes often have bad normals or topology for game engines.</li> <li>No Animations: Cannot export armatures, keyframes, or separate parts easily without splitting into many files.</li> <li>Material Complexity: Requires custom \"Triplanar Mapping\" shaders in the client because the model lacks UV coordinates.</li> </ul>"},{"location":"archive/SCAD_VS_BLENDER/#2-the-blender-pipeline-game-ready-assets","title":"2. The Blender Pipeline (\"Game-Ready Assets\")","text":"<p>Approach:</p> <ul> <li>Use Python scripting inside Blender (<code>bpy</code>) to generate geometry programmatically.</li> <li>Export directly to <code>.glb</code> (GLTF binary) which supports hierarchy, materials, and animations.</li> <li>Use standard Three.js loaders in the client.</li> </ul> <p>Code Snippet (<code>bulldozer.py</code>):</p> <pre><code>import bpy\n\n# Create Mesh\nbpy.ops.mesh.primitive_cube_add(size=1, location=(0, 0, 1.0))\nbody = bpy.context.object\nbody.name = \"Bulldozer_Body\"\nbody.scale = (2.5, 4.0, 1.5)\n\n# Assign Material\nmat = bpy.data.materials.new(name=\"YellowPaint\")\nbody.data.materials.append(mat)\n\n# Export\nbpy.ops.export_scene.gltf(filepath=\"bulldozer.glb\", export_format='GLB')\n</code></pre> <p>Pros:</p> <ul> <li>Rich Assets: Exports a complete scene with node hierarchy, proper names, and material slots.</li> <li>UV Unwrapping: Can automatically project UVs (<code>bpy.ops.uv.smart_project</code>), allowing standard textures.</li> <li>Animation Support: Capable of baking animations and skeletal rigs.</li> <li>Debugging: The generated file can be opened in Blender GUI for visual inspection.</li> <li>Standard Rendering: Works with standard <code>MeshStandardMaterial</code> without shader hacks.</li> </ul> <p>Cons:</p> <ul> <li>Dependency: Requires Blender to be installed on the build machine.</li> <li>Complexity: The Blender Python API is more complex than SCAD.</li> </ul>"},{"location":"archive/SCAD_VS_BLENDER/#conclusion-why-blender","title":"Conclusion: Why Blender?","text":"<p>We chose the Blender pipeline because it produces Game-Ready Assets. The OpenSCAD pipeline required too much runtime \"patching\" (custom shaders for triplanar mapping, manual material assignment, lack of object hierarchy). The Blender pipeline gives us a standard GLTF file that \"just works\" in Three.js, while still maintaining the benefits of procedural generation via Python scripts.</p>"},{"location":"planning/current/","title":"Current Plan: Refactoring &amp; Docs","text":"<p>Date: 2025-05-18 (Session Date)</p>"},{"location":"planning/current/#overview","title":"Overview","text":"<p>We are solidifying the DAMP pipeline and improving project documentation infrastructure.</p>"},{"location":"planning/current/#changes","title":"Changes","text":""},{"location":"planning/current/#1-code-maintenance","title":"1. Code Maintenance","text":"<ul> <li>Consolidated <code>cb()</code> Utility: Moved the cache-busting function from scattered files to <code>src/utils/graphics-utils.js</code>.</li> <li>Blender Parenting: Refactored <code>pipeline/blender/bulldozer.py</code> to use object parenting instead of mesh joining. This ensures that individual components (Wheels, Cabin) retain their <code>damp_id</code> contract tags in the exported GLB.</li> </ul>"},{"location":"planning/current/#2-documentation-system","title":"2. Documentation System","text":"<ul> <li>MkDocs: Setting up <code>mkdocs</code> with the <code>material</code> theme for a professional documentation site.</li> <li>Auto-Formatting: Integrating <code>mdformat</code> to keep documentation consistent.</li> <li>Deployment: Ensuring docs are built and published to <code>dist/docs</code> during PR previews.</li> </ul>"},{"location":"planning/current/#next-steps","title":"Next Steps","text":"<ul> <li>[ ] Verify the new GLB structure in the Asset Viewer.</li> <li>[ ] Verify the documentation site build.</li> </ul>"}]}